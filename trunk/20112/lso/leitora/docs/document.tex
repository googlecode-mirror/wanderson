\documentclass{article}

% Configurações Gerais ---------------------------------------------------------
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{sbc-template}
\usepackage{listings}

% Configurações Pacote Listings ------------------------------------------------
\renewcommand\lstlistingname{Código}
\lstset{language=c,basicstyle=\footnotesize\ttfamily,captionpos=b}

% Informações Pessoais ---------------------------------------------------------
\title{Relatório de TGB sobre Módulos de Kernel\\Implementação de Dispositivo de
Caractere para Verificação de Documentos do tipo CPF e CNPJ}
\author{Wanderson Camargo\inst{1} \and{} Bruno Fagundes\inst{1} \and{} Jeferson
Souza\inst{1}}
\address{Laboratório de Sistemas Operacionais --- 2011/2\\Centro de Ciências
Exatas e Tecnológicas\\Universidade do Vale do Rio dos Sinos ---
UNISINOS\email{\{wandersonwhcr,brunofagundes91,acdc.jeferson\}@gmail.com}}

% Corpo do Documento -----------------------------------------------------------
\begin{document}

\maketitle{}

\begin{resumo}
Trabalhando em espaço de Kernel, os módulos utilizados pelo Linux podem ser
utilizados no desenvolvimento de \textit{drivers} para dispositivos físicos.
Para aprendizado, podemos criar um dispositivo de caractere virtual capaz de
receber uma pequena quantidade de informação e executar uma tarefa simples sobre
a informação, apresentando resultados quando solicitado. Este dispositivo é
manipulado como um arquivo, portanto pode ser manipulado por chamadas de sistema
para escrita e leitura. Com base nisto, foi desenvolvido um \textit{driver}
capaz de manipular a informação recebida e apresentar se o seu conteúdo é
considerado um número de documento do tipo CPF ou CNPJ. Todos os passos de
desenvolvimento estão definidos neste artigo.
\end{resumo}

% Introdução -------------------------------------------------------------------
\section{Introdução}
\label{sec:introducao}

Este documento visa apresentar anotações sobre o que está sendo executado sobre
o desenvolvimento do Trabalho de Grau B para Laboratório de Sistemas
Operacionais, segundo semestre de 2012.

Neste trabalho, vamos criar um \textit{driver} para um dispositivo de caractere
como um módulo do kernel do Linux. Este \textit{driver} terá como funcionalidade
a verificação de uma sequência de caracteres que identificam um documento,
apresentando se o conteúdo deve ser considerado como um Cadastro de Pessoa
Física (CPF) ou um Cadastro Nacional de Pessoa Jurídica (CNPJ) válido.

A Seção \ref{sec:instalacao-inicial} explica os passos para a inicialização do
desenvolvimento, como estruturas de código e cabeçalhos que necessitam ser
instalados, bem como o código fonte do Kernel do Linux para desenvolvimento do
módulo. Nesta seção também são explicadas as etapas de compilação necessárias
para o código objeto do módulo a ser desenvolvido.

A Seção \ref{sec:exemplo-basico} fornece uma introdução à criação de módulos do
Kernel utilizando um exemplo básico. Ainda nesta Seção, vamos verificar como são
gerenciadas as instalações e remoções de módulos dentro do Sistema Operacional.

A verificadora é desenvolvida na Seção \ref{sec:verificadora}. Nesta parte do
relatório, é possível encontrar os passos necessários para iniciar um
dispositivo de caractere no Sistema Operacional na Subseção
\ref{subsec:alocacao-sisop}. As definições de operações sob arquivos são
apresentadas na Subseção \ref{subsec:definicao} e a alocação do dispositivo de
caractere em memória na Subseção \ref{subsec:alocacao-dispositivo}. Todas as
operações utilizadas no dispositivo estão definidas na Subseção
\ref{subsec:operacoes}.

Logo após, a abertura e liberação do dispositivo de caractere como arquivo é
criado a partir de códigos encontrados na Subseção
\ref{subsec:abertura-liberacao-arquivo}. A escrita em arquivo é criada na
Subseção \ref{subsec:escrita-arquivo} e a leitura na Subseção
\ref{subsec:leitura-arquivo}. No final desta Seção será apresentada a função que
executa o algoritmo de verificação dos documentos, definida na Subseção
\ref{subsec:algoritmo}.

Testes simples são apresentados na Seção \ref{sec:testes}. Ao final, são
apresentados os possíveis problemas encontrados durante a utilização do módulo e
conclusões sobre o desenvolvimento nas Seções \ref{sec:problemas} e
\ref{sec:finalizacao}, respectivamente.

% Instalação Inicial -----------------------------------------------------------
\section{Instalação Inicial}
\label{sec:instalacao-inicial}

Para inicializar o desenvolvimento, precisamos do código fonte do próprio Kernel
do Linux para utilização de seus cabeçalhos. Em um sistema baseado em Debian,
podemos instalar esta dependência através do comando descrito em
\lstlistingname{} \ref{lst:aptget}, com permissões de superusuário.

\begin{lstlisting}[caption={Linux Source},label={lst:aptget},language=sh]
apt-get install linux-source
\end{lstlisting}

Como este é um metapacote, precisamos especificar qual código fonte do Linux
será instalado, conforme saída do comando. Atualmente, estamos trabalhando
com a versão 2.6.32 do kernel. Logo, vamos instalar o código fonte com o comando
descrito em \lstlistingname{} \ref{lst:aptgets}.

\begin{lstlisting}[caption={Linux Source 2.6.32},label={lst:aptgets},language=sh]
apt-get install linux-source-2.6.32
\end{lstlisting}

% Compilação -------------------------------------------------------------------
\subsection{Compilação}
\label{subsec:compilacao}

Para facilitar a geração do módulo, quando instalamos o código fonte do Kernel,
algumas ferramentas são adicionadas. Porém, após uma pequena pesquisa na
documentação disponível, não encontramos nenhum tipo de explicação sobre o
porquê de utilizar os códigos descritos no Makefile. Após estudarmos o caso,
encontramos algumas explicações em sites e com testes. Temos o seguinte código
interno ao Makefile para utilizar o arquivo \texttt{main.c} como código fonte
para geração do código objeto \texttt{main.o}.

\begin{lstlisting}[caption={Makefile},label={lst:makefile},language=sh]
KVERSION   = $(shell uname -r)
KDIRECTORY = /lib/modules/$(KVERSION)/build

obj-m = main.o

all:
	make -C "$(KDIRECTORY)" "M=$(PWD)" modules

clean:
	make -C "$(KDIRECTORY)" "M=$(PWD)" clean
\end{lstlisting}

As duas primeiras linhas são configurações para melhorar a criação do Makefile,
onde poderemos alterar diretamente estas opções caso necessário. A variável
\texttt{KVERSION} armazena a versão atual do Kernel e \texttt{KDIRECTORY}
armazena o caminho dos arquivos necessários para criação do módulo e não dos
arquivos de cabeçalho utilizados no código fonte.

O conjunto de instruções com a etiqueta \texttt{all} constrói o código objeto do
módulo solicitado. O parâmetro \texttt{-C} modifica o diretório atual do
\texttt{make} para o \texttt{KDIRECTORY}, que possui um outro \texttt{Makefile}
configurado e especializado para criar módulos do Kernel. O parâmetro
\texttt{M=} apresenta o diretório atual para o \texttt{Makefile} interno ao
\texttt{KDIRECTORY}, que irá procurar pela opção \texttt{obj-m} para gerar
código objeto do módulo esperado. Esta configuração deve possuir o mesmo nome do
arquivo de código fonte com sufixo \texttt{*.o}, representando a geração do
código objeto para aquele arquivo.

A opção \texttt{clean} limpa os arquivos gerados dentro do diretório atual,
intermediários ou resultantes da criação do objeto módulo previamente
construído. Os dois comandos de terminal descritos em \lstlistingname{}
\ref{lst:makeclean} descrevem como gerar o código objeto e limpar os arquivos
gerados durante a execução desta tarefa, utilizando o comando \texttt{make}.

\begin{lstlisting}[caption={Utilização Makefile},label={lst:makeclean},language=sh]
make
make clean
\end{lstlisting}

A primeira linha apresenta a instrução que gera o código objeto \texttt{main.ko}
que representa o nosso módulo que poderá ser aplicado no Kernel do Linux. A
segunda instrução limpa todos os arquivos gerados pela execução de criar o
código objeto, incluindo o próprio módulo gerado.

% Exemplo Básico ---------------------------------------------------------------
\section{Exemplo Básico}
\label{sec:exemplo-basico}

Baseado em \cite{corbet2005}, vamos construir um código fonte capaz de gerar um
módulo simples do Linux. As duas instruções necessárias para criar um módulo são
apresentadas: a que inicia o módulo junto ao Kernel do Linux e a que é utilizada
para remover o módulo e desregistrar algumas funcionalidades inicializadas
anteriormente.

\begin{lstlisting}[caption={Exemplo de Módulo},label={lst:exemplo}]
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void)
{
    printk(KERN_ALERT "Hello, World\n");
    return 0;
}

static void hello_exit(void)
{
    printk(KERN_ALERT "Goodbye, Cruel World\n");
}

module_init(hello_init);
module_exit(hello_exit);
\end{lstlisting}

As duas primeiras linhas são necessárias para incluir os cabeçalhos de funções
de inicialização e de módulo, respectivamente. Durante a geração do código
objeto, os caminhos de inclusão são configurados pelo \texttt{Makefile} interno
ao diretório \texttt{KDIRECTORY} especificado anteriormente.

Após, a licença de utilização do módulo é apresentada. Esta chamada não é
necessária mas o seu conteúdo é apresentado quando utilizado o programa
\texttt{modinfo}, que exibe informações de um módulo ainda como um código
objeto. A chamada \texttt{MODULE\_LICENSE} é uma macro e pode receber outros
parâmetros, definidos em \texttt{linux/module.h}.

Basicamente, qualquer função pode ser considerada como inicialização ou
finalização de módulo, desde que obedeçam a sua assinatura. Funções de
inicialização não devem receber parâmetros e retornar um inteiro que representa
a execução com sucesso de sua inicialização. Da mesma forma, a função de
finalização não recebe parâmetros, porém não retorna valores. Estas funções
necessitam ser registradas utilizando as funções \texttt{module\_init} e
\texttt{module\_exit}, conforme a necessidade. Utilizando testes locais, as
funções não necessitam ser estáticas, conforme exemplo superior.

A função \texttt{printk} trabalha da mesma maneira que a função \texttt{printf},
porém em espaço de kernel, já que as funções padrão do C não estão disponíveis.
Podemos verificar que não há concatenação da constante \texttt{KERN\_ALERT} e o
texto que deve ser apresentado. Como uma \texttt{string} em C é uma cadeia de
caracteres, o compilador entende que duas \texttt{strings} lado a lado devem ser
consideradas como únicas. Se há uma separação por vírgula, a função
\texttt{printk} recebe como primeiro parâmetro um padrão para formatar a saída e
os seguintes são considerados cada um como um parâmetro deste padrão. Como não
há nenhum padrão definido dentro de \texttt{KERN\_ALERT}, teremos uma mensagem
de aviso em tempo de construção do código objeto.

A constante \texttt{KERN\_ALERT} apenas é uma \texttt{string} que informa o
nível de prioridade. Neste caso, o seu conteúdo representa o nível mais alto de
aviso. O seu conteúdo é somente um \texttt{<1>}.

Por fim, a função \texttt{printk} é utilizada em ambas funções registradas,
representando a inserção e remoção do módulo do Linux. Agora veremos como
podemos gerenciar estes módulos diretamente no Kernel.

% Gerenciamento ----------------------------------------------------------------
\subsection{Gerenciamento}
\label{subsec:gerenciamento}

O módulo gerado como código objeto pode ser inserido e removido do Kernel do
Linux em tempo de execução. Para isto, vamos utilizar comandos específicos de
linha de comando como superusuário. Abaixo estão descritos os dois comandos que
inserem e removem o módulo anteriormente desenvolvido. Precisamos executar o
\texttt{make} e utilizar o arquivo \texttt{main.ko}, módulo gerado.

\begin{lstlisting}[caption={Gerenciamento de Módulo},label={lst:germod},language=sh]
insmod main.ko
rmmod main.ko
\end{lstlisting}

Dependendo da configuração que estamos utilizando e o ambiente de execução, como
janelas em ambientes gráficos, não vamos visualizar a saída esperada das funções
\texttt{printk}. Neste caso, o conteúdo gerado é armazenado em arquivos de
\texttt{log} do sistema. Em \cite{corbet2005}, é informado que este conteúdo é
enviado para o arquivo \texttt{/var/logs/messages}, porém no sistema Debian
utilizado para desenvolver este documento o conteúdo foi enviado para
\texttt{/var/logs/kern.log}.

Para fins de testes e verificar se a nossa saída está sendo enviada corretamente
durante as execuções de inserção e remoção do módulo, podemos antes executar o
comando \texttt{tail -f /var/logs/kern.log} para efetuar a leitura constante do
conteúdo armazenado no arquivo. Sempre que algo é armazenado neste, o comando
\texttt{tail} apresenta na saída padrão o conteúdo capturado.

% Instalador Simples -----------------------------------------------------------
\subsection{Instalador Simples}
\label{subsec:instalador-simples}

Para auxiliar no desenvolvimento, deve ser criado um instalador simples que
facilita na manipulação do módulo dentro do sistema. Vamos criar algumas linhas
de configurações, inicializando variáveis num arquivo de código fonte no formato
Shellscript.

\begin{lstlisting}[caption={Instalador Simples},label={lst:inst-head},language=sh]
USERID=$(id -u)
DRIVER_NAME="verifier"
DEVICE_NAME="verifier"
\end{lstlisting}

Após devemos verificar se o usuário atual é o que possui \texttt{uid}
(identificador do usuário) igual a 0 (zero), ou seja, o usuário raiz do sistema.
Esta tarefa deve ser executada sobre o número identificador porque seu nome pode
ser modificado, porém este valor não. Para auxiliar no tratamento de erro,
criamos uma função que formata uma saída e possui encapsulados uma execução de
finalização.

\begin{lstlisting}[caption={Tratamento de Erro},label={lst:inst-error},language=sh]
function verifier_error() {
    echo ERROR: $1
    if [ ! -z $2 ]; then
        exit $2
    fi
}
if [ $USERID -ne 0 ]; then
    verifier_error "Necessário Usuário Raiz" 1
fi
\end{lstlisting}

Posteriormente, vamos inserir o módulo no Kernel do Linux utilizando o comando
específico, esperando que sua execução tenha finalizado com sucesso. Caso
contrário, vamos gerar um erro dentro da instalação.

\begin{lstlisting}[caption={Instalar Módulo},label={lst:inst-succ},language=sh]
insmod "$DRIVER_NAME.ko"
if [ $? -ne 0 ]; then
    verifier_error "Impossível Instalar Módulo" 2
fi
\end{lstlisting}

Como o nosso módulo possui uma criação dinâmica de número maior, devemos
capturar este valor do conteúdo armazenado no arquivo com dispositivos do
sistema. Se ele não existir ou não estiver sido encontrado, também vamos gerar
um erro e finalizar a execução com uma saída diferente de zero.

\begin{lstlisting}[caption={Driver},label={lst:inst-driver},language=sh]
MAJOR=$(grep "$DRIVER_NAME" /proc/devices | cut -d' ' -f1)
if [ -z $MAJOR ]; then
    verifier_error "Impossível Encontrar Número Maior" 3
fi
\end{lstlisting}

Finalizando, vamos remover qualquer tipo de dispositivo com o mesmo nome,
previamente criado e adicionar o nosso dispositivo de caractere com o mesmo
número maior do módulo adicionado anteriormente. No nosso caso, o número menor
não é significativo, portanto vamos configurá-lo com valor zero. Finalizamos o
instalador com uma saída igual a zero, demonstrando sucesso de execução.

\begin{lstlisting}[caption={Dispositivo de Caractere},label={lst:inst-char},language=sh]
rm -f "/dev/$DEVICE_NAME"
mknod "/dev/$DEVICE_NAME" c "$MAJOR" 0
chmod 666 "/dev/$DEVICE_NAME"
exit 0
\end{lstlisting}

% Verificadora -----------------------------------------------------------------
\section{Verificadora}
\label{sec:verificadora}

Vamos inicializar o desenvolvimento da verificadora de CPF/CNPJ, base da
Proposta de Trabalho de Grau B para a disciplina de Laboratório de Sistemas
Operacionais. Precisamos inicialmente criar um módulo que consiga gerar um
\textit{número maior} automaticamente, com base no código fonte apresentado por
\cite{corbet2005}.

Logo nas primeiras linhas, vamos configurar as informações do módulo, acessíveis
dentro do sistema operacional utilizando a função \texttt{modinfo}. Informamos
uma pequena descrição do módulo e seus autores, bem como o número da versão
atual e a licença de utilização do mesmo. Abaixo, apenas definimos algumas
constantes para utilização dentro da programação do módulo, que serão resolvidas
logo no início pelo pré-compilador.

\begin{lstlisting}[caption={Informações Básicas},label={lst:verifier-def}]
MODULE_DESCRIPTION("Driver para Verificadora de CPF e CNPJ");
MODULE_AUTHOR("Wanderson Henrique Camargo Rosa <wandersonwhcr@gmail.com>");
MODULE_AUTHOR("Jeferson Souza <jeferson.s.souza@hotmail.com>");
MODULE_AUTHOR("Bruno Fagundes <web@bfagundes.com>");
MODULE_VERSION("0.1b");
MODULE_LICENSE("Dual BSD/CPL");

#define DRIVER_NAME "verifier"
#define MINOR_NUMBER 0
#define DEVICE_COUNTER 1
\end{lstlisting}

Vamos adicionar as assinaturas das duas primeiras funções que serão
desenvolvidas durante o processo. Logo abaixo, elas são registradas como
inicialização e finalização de módulo. Conforme necessário, estas funções
possuem assinaturas compatíveis com os registradores de funções.

\begin{lstlisting}[caption={Inicialização},label={lst:verifier-hooks}]
int verifier_init(void);
void verifier_exit(void);

module_init(verifier_init);
module_exit(verifier_exit);
\end{lstlisting}

Para manipulação, vamos inicializar uma variável global e interna ao módulo para
armazenar o número referente ao dispositivo alocado. Este dispositivo
corresponde ao criado e anexado com o número maior dentro do instalador. No
nosso caso, o dispositivo deverá se chamar \texttt{verifier} e será criado
dentro do diretório de dispositivos padrão. Ele deve ser alocado dentro da
função de inicialização do módulo. Adicionamos algumas mensagens que serão
visualizadas somente no arquivo descrito na seção inicial deste documento.

\begin{lstlisting}[caption={Inicialização de Módulo},label={lst:verifier-init}]
// Vairável Global
dev_t device;
// Função de Inicialização
int verifier_init(void) {
    int result;
    printk(KERN_INFO "Inicialização de Verificadora CPF/CNPJ");
    result = alloc_chrdev_region(&device, MINOR_NUMBER, DEVICE_COUNTER, DRIVER_NAME);
    if (result == 0) {
        printk(KERN_INFO "Inicialização com Sucesso");
    } else {
        printk(KERN_ALERT "Impossível Alocação de Dispositivo");
    }
    return result;
}
\end{lstlisting}

Buscando alocar o módulo, utilizamos a função específica para alocar um
dispositivo sem a existência de um número maior sendo informado dentro do código
fonte. Para outros elementos, utilizamos nossas definições descritas. Devemos
também apresentar os resultados ao final de inicializar o módulo.

Já a função de finalização é desenvolvida de maneira mais simples, solicitando
uma retirada do registro de dispositivos alocados o nosso alocado na
inicialização. Para isto, somente precimos informar o próprio valor do
dispositivo e a quantidade de elementos que devem sofrer esta ação; definido
anteriormente, o número de dispositivos é 1 (um).

\begin{lstlisting}[caption={Saída de Módulo},label={lst:verifier-exit}]
void verifier_exit(void) {
    printk(KERN_INFO "Finalização de Verificadora CPF/CNPJ");
    unregister_chrdev_region(device, DEVICE_COUNTER);
    printk(KERN_INFO "Finalização com Sucesso");
}
\end{lstlisting}

Com isto, temos um módulo que aloca um dispositivo para manipulação, anexando-se
ao elemento através de um número maior. No nosso caso, o instalador captura o
número variado criado.

Temos então um pequeno módulo de Kernel do Linux que aloca um determinado
dispositivo. Este módulo trabalha como um \textit{driver}. Como vamos criar uma
leitora de dados, precisamos adicionar funções de abertura, leitura, escrita e
fechamento deste dispositivo de caracteres, gerando assim nosso módulo de
verificação de CPF e CNPJ.

% Alocação no Sistema Operacional ----------------------------------------------
\subsection{Alocação no Sistema Operacional}
\label{subsec:alocacao-sisop}

Neste momento, vamos inicializar um dispositivo de caractere dentro do sistema
operacional, fornecendo as operações que devem ser executadas quando o
dispositivo é acessado. Precisamos implementar 4 tipos de operações básicas:
abertura, leitura, escrita e fechamento do dispositivo de caracteres. Portanto,
precisamos implementar 4 funções que executam esta tarefa e fornecer a uma
estrutura com esta responsabilidade dentro da programação. Na área de
assinaturas de funções, vamos fornecer os seguintes protótipos.

\begin{lstlisting}[caption={Protótipos}]
int verifier_open(struct inode*, struct file*);
ssize_t verifier_read(struct file*, char __user*, size_t, loff_t*);
ssize_t verifier_write(struct file*, const char __user*, size_t, loff_t*);
int verifier_release(struct inode*, struct file*);
\end{lstlisting}

Cada uma destas inicializações possui as suas características. A função para
leitura recebe como primeiro parâmetro um ponteiro para estrutura do
representante do arquivo dentro do sistema operacional; o segundo parâmetro
identifica o mesmo arquivo, porém com informações de sua abertura. Logo, temos
que o \texttt{inode} apresenta informações sobre a estrutura física do arquivo e
o parâmetro \texttt{file} apresenta informações sobre os descritores
inicializados para este arquivo.

Para executar a leitura, a segunda função armazena todas as execuções para esta
finalidade. O primeiro parâmetro \texttt{file}, assim como durante a abertura,
representa o arquivo aberto dentro do sistema, com informações sobre os
descritores inicializados. Já o segundo parâmetro \texttt{\_\_user} representa
um ponteiro do tipo caractere para região de memória em espaço de usuário. O
parâmetro \texttt{size\_t} indica a quantidade de \textit{bytes} que devem ser
fornecidos para a leitura. O último parâmetro \texttt{loff\_t} fornece a posição
atual da leitura no arquivo apresentado. Como retorno, temos a quantidade de
caracteres processados com sucesso.

Com base na estrutura de leitura, a escrita recebe as mesmas quantidades de
parâmetros com funcionalidades semelhantes, porém o terceiro parâmetro
\texttt{\_\_user} define um ponteiro para a região de memória em espaço de
usuário que armazena os valores para processamento.

As funções de leitura e escrita possuem uma peculiaridade, o valor de retorno
que representa a quantidade de caracteres processados. Se a função retorna o
mesmo valor solicitado para o utilização, então toda a quantidade de elementos
apresentada foi processada. Já se o valor retornado é menor do que o solicitado,
então uma quantidade menor foi processada. Se o valor retornado é igual a zero,
o final do arquivo foi alcançado. Por último, se o valor retornado é negativo,
então houve um erro durante o processamento. Estes erros estão definidos em
\texttt{linux/errno.h}.

A última função representa o fechamento do arquivo pelo sistema operacional.
Esta somente é utilizada se todos os descritores de todos os processos foram
finalizados com sucesso. Caso seja necessário algum processamento quando um
descritor somente é fechado, temos que utilizar a função \texttt{flush}, não
definida no escopo acima.

% Definição de Operações -------------------------------------------------------
\subsection{Definição de Operações}
\label{subsec:definicao}

Para que as operações sejam apresentadas ao dispositivo de caractere que será
alocado no sistema operacional, precisamos armazená-las em uma estrutura com
esta finalidade. Esta estrutura do tipo \texttt{file\_operations} recebe
ponteiros para as funções definidas nos protótipos.

\begin{lstlisting}[caption={Operações em Arquivos}]
struct file_operations verifier_fops = {
    .read    = verifier_read,
    .write   = verifier_write,
    .open    = verifier_open,
    .release = verifier_release,
};
\end{lstlisting}

Assim, temos uma estrutura de nome \texttt{verifier\_fops} com os ponteiros
devidamente inicializados com as funções para manipulação de arquivos. Vale
lembrar que estas funções necessitam possuir os parâmetros necessários,
característica de sua tipagem. Este tipo de inicialização de estrutura
corresponde ao formato C99.

% Alocação do Dispositivo ------------------------------------------------------
\subsection{Alocação do Dispositivo}
\label{subsec:alocacao-dispositivo}

Agora vamos alocar o dispositivo de caractere no sistema operacional, fornecendo
a estrutura de operações em arquivos definida anteriormente. Logo após a
confirmação de inicialização com sucesso do \textit{driver}, vamos solicitar ao
sistema a alocação de um novo dispositivo de caractere.

\begin{lstlisting}[caption={Alocação do Dispositivo}]
// Definido como Global
struct cdev *cdevice;
// Estrutura de Inicialização
cdevice = cdev_alloc();
cdevice->ops = &verifier_fops;
result = cdev_add(cdevice, device, DEVICE_COUNTER);
\end{lstlisting}

Com a devida alocação do dispositivo, apresentamos como operadores o endereço
para a estrutura com os operadores de arquivos definida anteriormente.  A
terceira linha tenta adicionar o dispositivo no sistema operacional, utilizando
como primeiro parâmetro o dispositivo alocado e segundo o dispositivo físico
inicializado com o \textit{driver}. O último parâmetro representa a quantidade
de dispositivos que irão ser utilizados com esta alocação.

Vale lembrar que \texttt{cdevice} é uma variável global que está definida fora
do escopo das funções e pode ser acessada por qualquer uma delas, inclusive na
finalização do módulo, que precisa desalocar o recurso. Já a variável
\texttt{device} e a definição \texttt{DEVICE\_COUNTER} foram criadas
anteriormente, durante a inicialização básica do módulo. Novamente, vamos
armazenar o resultado do processamento em \texttt{result} e criar um tratamento
de possível erro de alocação.

\begin{lstlisting}[caption={Tratamento em Alocação}]
if (result == 0) {
    // Alocação com Sucesso
    printk(KERN_INFO "Alocação com Sucesso");
} else {
    // Alocação com Erros
    printk(KERN_ALERT "Impossível Alocar Dispositivo no Sistema");
}
\end{lstlisting}

Agora precisamos desalocar a inicialização do dispositivo de caractere no
sistema operacional. Durante a finalização do módulo, antes de remover a região
disponibilizada para o dispositivo, vamos desalocar o dispositivo de caractere.

\begin{lstlisting}[caption={Desalocação do Dispositivo}]
cdev_del(cdevice);
\end{lstlisting}

Assim, temos o nosso dispositivo de caractere devidamente inicializado, bastando
escrever as funções com operações de arquivos que somente foram definidas como
protótipos.

% Escrita de Operações ---------------------------------------------------------
\subsection{Escrita de Operações}
\label{subsec:operacoes}

As operações iniciais para arquivos devem ser definidas de forma bem simples,
somente para fornecer ao sistema operacional as devidas entradas. As próximas
seções do documento deverão discutir cada uma delas. Por hora, as funções de
abertura e fechamento retornam sucesso para qualquer solicitação; já as
responsáveis pela leitura e escrita somente apresentam a quantidade de
\textit{bytes} processados e final de arquivo, respectivamente.

\begin{lstlisting}[caption={Operações no Dispositivo}]
// Abertura
int verifier_open(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Abertura de Arquivo");
    return 0;
}
// Leitura
size_t verifier_read(struct file* filp, char __user* buffer, size_t count, loff_t* offp) {
    printk(KERN_DEBUG "Leitura em Arquivo");
    return count;
}
// Escrita
ssize_t verifier_write(struct file* filp, const char __user* buffer, size_t count, loff_t* offp) {
    printk(KERN_DEBUG "Escrita em Arquivo");
    return count;
}
// Fechamento
int verifier_release(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Fechamento de Arquivo");
    return 0;
}
\end{lstlisting}

As exibições do tipo \texttt{KERN\_DEBUG} não são armazenadas no arquivo de
mensagens, mas somente no arquivo \texttt{/var/log/kern.log}. Como todas as
mensagens podem ser acessdas neste local, podemos utilizar o comando
\texttt{tail -f} neste arquivo para visualizar as saídas em \texttt{printk}
apresentadas no programa.

Como temos todas as inicializações para operações com arquivos devidamente
inicializadas, podemos começar o desenvolvimento da implementação da
verificadora de documentos do tipo CPF e CNPJ, proposta do Trabalho de Grau B
desta disciplina.

% Abertura e Liberação de Arquivo ----------------------------------------------
\subsection{Abertura e Liberação de Arquivo}
\label{subsec:abertura-liberacao-arquivo}

Durante a abertura e fechamento de arquivos, precisamos desenvolver duas funções
para que saibamos quando estas duas execuções estão sendo chamadas. Porém, como
não estaremos utilizando realmente arquivos, podemos somente confirmar ao
sistema operacional a abertura e fechamento dos recursos, retornando o valor de
sucesso. Somente para auxiliar o desenvolvimento, exibimos mensagens sempre que
estas funções são executadas, exibindo o tempo de abertura e fechamento do
arquivo.

\begin{lstlisting}[caption={Abertura e Liberação}]
int verifier_open(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Abertura de Arquivo");
    return 0;
}
int verifier_release(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Fechamento de Arquivo");
    return 0;
}
\end{lstlisting}

A abertura é feita sempre que um processo solicita a abertura do arquivo pela
primeira vez. Porém, se outro processo já executou esta solicitação, teremos a
função não será executada novamente, tendo em vista que o \texttt{inode} já foi
aberto pelo sistema operacional. Da mesma forma, a liberação do recurso pela
função de fechamento do arquivo somente é executada quando todos os descritores
daquele arquivo foram finalizados. Se precisamos chamar algum recurso quando um
único descritor é finalizado, devemos utilizar a função \texttt{flush}, não
utilizada neste trabalho.

% Escrita de Arquivo -----------------------------------------------------------
\subsection{Escrita de Arquivo}
\label{subsec:escrita-arquivo}

A função para escrita em arquivo sempre é chamada quando algum processo executa
a chamada de sistema para escrita em descritor representante. Portando, sempre
que existe uma escrita, a função de abertura de arquivo já foi executada
anteriormente. Primeiramente, vamos desenvolver uma estruturação simples que
busca apresentar um erro de entrada e saída sempre que um processo tenta
executar uma escrita na leitora.

\begin{lstlisting}[caption={Escrita}]
ssize_t verifier_write(struct file* filp, const char __user* buffer, size_t count, loff_t* offp) {
    int result = -EIO; // Problema de Entrada e Saída
    printk(KERN_DEBUG "Escrita em Arquivo");
    if (count == 12 || count == 15) { // (CPF|CNPJ) + 1
        // Tamanho Válido do Documento
    } else {
        // Tamanho do Documento Inválido
        printk(KERN_ALERT "Documento não Reconhecido");
    }
    return result;
}
\end{lstlisting}

Neste bloco de código também colocamos a verificação da quantidade de caracteres
que foi informada para escrita. Sem os caracteres de máscara, um documento do
tipo CPF possui 11 caracteres e um CNPJ possui 14 caracteres. Porém, devemos
considerar o caractere identificador de final de string, portando sempre
verificamos se existe a quantidade solicitada adicionada de uma unidade.

Agora podemos iniciar a captura dos caracteres apresentados. Vamos então salvar
em memória no espaço de Kernel a informação passada durante a chamada da função.
Para isto, precisamos alocar um espaço de memória com a mesma quantidade de
\textit{bytes} que foi apresentada durante a escrita. Vamos então criar uma
variável global do tipo ponteiro de caractere. Para facilitar a contabilização
do tamanho de memória alocada, também vamos criar uma variável global para
armazenar esta informação.

\begin{lstlisting}[caption={Memória Auxiliar}]
char *memory;
int memorysize;
\end{lstlisting}

Agora vamos liberar o espaço de memória, porque ele pode ter sido alocado em
situações anteriores de escrita. Logo após, alocamos um espaço de memória do
mesmo tamanho da quantidade de caracteres apresentada, utilizando uma alocação
normal de Kernel.

\begin{lstlisting}[caption={Limpeza de Memória}]
kfree(memory);
memory = kmalloc(count, GFP_KERNEL);
\end{lstlisting}

Caso esta alocação não tenha sido executada com sucesso, o valor da posição em
memória retornada será nula. Caso isto aconteça, vamos informar sobre o
problema.

\begin{lstlisting}[caption={Alocação de Memória}]
if (memory != NULL) {
    // Alocação com Sucesso
} else {
    printk(KERN_ALERT "Problema na Alocação de Memória");
}
\end{lstlisting}

Com sucesso durante a alocação de memória, somente vamos limpar o espaço de
memória fornecido conforme a quantidade de espaço alocada. Portanto, vamos
preencher o espaço de memória com valores iniciais.

\begin{lstlisting}[caption={Preenchimento de Memória}]
memset(memory, 0, count);
\end{lstlisting}

Agora precisamos copiar os caracteres que foram apresentados durante a chamada
de sistema para escrita em arquivo. Estes caracteres estão armazenados em espaço
de usuário e devem ser copiados para espaço de Kernel para manipulação.
Precisamos contabilizar a quantidade de caracteres necessários e armazenar este
valor na variável global para tamanho de memória.

Utilizando uma função específica para cópia de conteúdo do espaço de usuário
para espaço de Kernel, precisamos apresentar a posição de memória destino da
cópia, ou seja, a memória alocada inicialmente. Também vamos apresentar o local
onde o conteúdo origem está armazenado em espaço de usuário e a quantidade de
caracteres que será copiada.

Esta chamada para cópia retorna a quantidade de \textit{bytes} que não foram
processados.  Caso a função apresente valor igual a zero, temos todos os
\textit{bytes} copiados com sucesso; caso contrário teremos um erro ao copiar os
caracteres do documento. Em sucesso, vamos apresentar a quantidade de caracteres
processados no resultado da função, não mais informando problema de entrada e
saída.

\begin{lstlisting}[caption={Cópia para Espaço de Kernel}]
memorysize = count - 1; // Tamanho da Memória
if (copy_from_user(memory, buffer, memorysize) == 0) {
    printk(KERN_INFO "Conteúdo Escrito: %s", memory);
    result = count; // Sucesso no Processamento
} else {
    printk(KERN_ALERT "Erro ao Copiar Conteúdo do Documento");
}
\end{lstlisting}

O código para escrita em arquivo para a verificadora foi finalizado com sucesso.
Esta função exige que a quantidade de caracteres escrita esteja do mesmo tamanho
que um documento do tipo CPF ou CNPJ sem máscara. Qualquer erro encontrado
apresenta um problema de entrada e saída. Abaixo temos o código completo com
todos os passos para processamento de escrita ao dispositivo de caractere.

\begin{lstlisting}[caption={Função Completa de Escrita}]
// Variáveis Globais
char *memory;
int memorysize;

// Função de Escrita
ssize_t verifier_write(struct file* filp, const char __user* buffer, size_t count, loff_t* offp) {
    int result = -EIO; // Problema de Entrada e Saída
    printk(KERN_DEBUG "Escrita em Arquivo");
    if (count == 12 || count == 15) { // (CPF|CNPJ) + 1
        kfree(memory);
        memory = kmalloc(count, GFP_KERNEL);
        if (memory != NULL) {
            memset(memory, 0, count);
            memorysize = count - 1; // Tamanho da Memória
            if (copy_from_user(memory, buffer, memorysize) == 0) {
                printk(KERN_INFO "Conteúdo Escrito: %s", memory);
                result = count; // Sucesso no Processamento
            } else {
                printk(KERN_ALERT "Erro ao Copiar Conteúdo do Documento");
            }
        } else {
            printk(KERN_ALERT "Problema na Alocação de Memória");
        }
    } else {
        // Tamanho do Documento Inválido
        printk(KERN_ALERT "Documento não Reconhecido");
    }
    return result;
}
\end{lstlisting}

% Leitura em Arquivo -----------------------------------------------------------
\subsection{Leitura em Arquivo}
\label{subsec:leitura-arquivo}

A leitura do arquivo necessita de que o número de documento CPF e CNPJ seja
anteriormente apresentado com uma escrita em arquivo. Logo, precisamos armazenar
na leitora o número do documento antes de efetuar a chamada de sistema para
leitura do arquivo, caso contrário teremos um problema de entrada e saída,
apresentado caso este erro seja encontrado.

\begin{lstlisting}[caption={Leitura em Arquivo}]
ssize_t verifier_read(struct file* filp, char __user* buffer, size_t count, loff_t* offp) {
    int result = -EIO; // Erro de Entrada e Saída
    printk(KERN_DEBUG "Leitura em Arquivo");
    return result;
}
\end{lstlisting}

Precisamos saber se a posição de memória que contém informações sobre o número
de documento para verificação foi inicializada corretamente ou se ela já foi
utilizada em algum momento do processamento. Se a posição já foi utilizada,
vamos armazenar o valor nulo posteriormente. Agora, precisamos saber qual é o
conteúdo deste ponteiro de memória e se ele já foi processado.

\begin{lstlisting}[caption={Verificar Alocação}]
// Verificar Alocação de Memória
if (memory != NULL) {
    // Inicializada e Não Utilizada
} else {
    // Não Inicializada ou Utilizada Anteriormente
}
\end{lstlisting}

Se a posição de memória foi inicializada e não utilizada, devemos utilizar o seu
conteúdo e verificar o valor armazenado, fazendo uma confirmação de documento
CPF ou CNPJ com valor correto. Isto será desenvolvido posteriormente, porém
vamos efetuar a chamada da função responsável e adicionar o seu protótipo no
topo do documento. O seu retorno será armazenado em uma variável global que
apresenta a última verificação. O código abaixo apresenta o conteúdo a ser
armazenado como global.

\begin{lstlisting}[caption={Elementos para Verificação}]
// Protótipo
char verifier_document(char*,int);
// Variável Global para Última Verificação
char lastcheck;
\end{lstlisting}

A execução da verificação será encapsulada na função, porém como temos o
protótipo adicionado, poderemos utilizar a função normalmente neste local. A
função de verificação recebe como primeiro parâmetro a posição de memória para
verificação e como segundo a quantidade de caracteres que devem ser verificados,
identificando assim um documento do tipo CPF ou CNPJ.

\begin{lstlisting}[caption={Encapsulamento de Verificação}]
// Processar Resultado
lastcheck = verifier_document(memory, memorysize);
printk(KERN_INFO "Resultado de Verificação: %c", lastcheck);
\end{lstlisting}

Este retorno será apresentado à chamada de sistema como único caractere
resultado da leitura, identificando assim o resultado da verificação do
documento. Este caractere deve ser copiado para o espaço de usuário como
resultado da leitura. Em caso de sucesso, teremos que desalocar a memória
inicializada anteriormente durante a escrita, limpar o ponteiro deste local e
reduzir o tamanho da memória a zero, identificando assim o final da verificação
do documento. O retorno será marcado como 1, confirmando a leitura do único
caractere apresentado ao espaço de usuário.

A função de cópia para espaço de usuário retorna a quantidade de caracteres que
não foram processados. Caso o único caractere não tenha sido copiado, vamos
apresentar uma mensagem de alerta.

\begin{lstlisting}[caption={Cópia para Espaço de Usuário}]
if (copy_to_user(buffer, &lastcheck, 1) == 0) {
    printk(KERN_INFO "Conteúdo Lido: %c", lastcheck);
    // Limpar Memória
    kfree(memory);
    memory = NULL;
    memorysize = 0;
    // Quantidade de Leitura
    result = 1; // Somente 1 Caractere
} else {
    printk(KERN_ALERT "Erro ao Copiar o Conteúdo de Resposta");
}
\end{lstlisting}

Por outro lado, se a posição de memória está com valor nulo, seu processamento
não foi inicializado corretamente ou sua verificação já foi executada. Devemos
consultar a variável que armazena a última verificação. Em caso de sucesso ou
falha, o conteúdo foi processado. Caso contrário, vamos apresentar uma mensagem
de alerta informando que a posição não foi inicializada corretamente.

\begin{lstlisting}[caption={Consulta de Última Verificação}]
// Verificar Última Leitura
if (lastcheck == VERIFIER_SUCCESS || lastcheck == VERIFIER_FAIL) {
    // Quantidade de Leitura
    lastcheck = VERIFIER_WAIT; // Estado em Espera
    result = 0; // Sinalização de Final do Arquivo
    printk(KERN_ALERT "Final do Arquivo Encontrado");
} else {
    printk(KERN_ALERT "Conteúdo não Inicializado Anteriormente");
}
\end{lstlisting}

Ainda em caso de sucesso ou falha na verificação do conteúdo, temos o resultado
que será apresentado no retorno da função de leitura marcado como nenhum
caractere lido. Isto sinaliza o final do arquivo. Precisamos executar esta
marcação porque muitos programas executam a leitura sobre o conteúdo de todo o
arquivo; caso este valor não seja apresentado, teremos gerado uma leitura que
nunca será finalizada.

Este código também apresenta algumas constantes, utilizadas como retorno da
verificadora do conteúdo do documento. Estas constantes estão definidas fora do
escopo da função de leitura e são utilizadas internamente como marcadores de
documento com conteúdo processado com sucesso, falha no processamento ou que a
leitora está em estado de espera de conteúdo para escrita.

\begin{lstlisting}[caption={Definições de Estado da Leitura}]
// Definições
#define VERIFIER_SUCCESS '0'
#define VERIFIER_FAIL '1'
#define VERIFIER_WAIT '2'
\end{lstlisting}

Estes valores também são os conteúdo apresentados para a leitura da
verificadora, sinalizando sucesso ou falha na verificação do conteúdo do
documento solicitado.

O bloco de código para leitura do arquivo é apresentado de forma completa. Temos
a verificação do conteúdo somente se uma escrita na verificadora foi executada
anteriormente, caso contrário apresentamos um erro de entrada e saída. Este
conteúdo é apresentado para a função de verificação, que apresenta um resultado
de sucesso ou falha no resultado da checagem. Este conteúdo também é enviado
para o espaço de usuário informando, trabalhando como caracteres resultados da
leitura. Na próxima requisição de leitura, apresentamos um resultado zerado,
sinalizando o final do arquivo.

\begin{lstlisting}[caption={Função Completa de Leitura}]
ssize_t verifier_read(struct file* filp, char __user* buffer, size_t count, loff_t* offp) {
    int result = -EIO; // Erro de Entrada e Saída
    printk(KERN_DEBUG "Leitura em Arquivo");
    // Verificar Alocação de Memória
    if (memory != NULL) {
        lastcheck = verifier_document(memory, memorysize);
        printk(KERN_INFO "Resultado de Verificação: %c", lastcheck);
        if (copy_to_user(buffer, &lastcheck, 1) == 0) {
            printk(KERN_INFO "Conteúdo Lido: %c", lastcheck);
            // Limpar Memória
            kfree(memory);
            memory = NULL;
            memorysize = 0;
            // Quantidade de Leitura
            result = 1; // Somente 1 Caractere
        } else {
            printk(KERN_ALERT "Erro ao Copiar o Conteúdo de Resposta");
        }
    } else {
        // Verificar Última Leitura
        if (lastcheck == VERIFIER_SUCCESS || lastcheck == VERIFIER_FAIL) {
            // Quantidade de Leitura
            lastcheck = VERIFIER_WAIT; // Estado em Espera
            result = 0; // Sinalização de Final do Arquivo
            printk(KERN_ALERT "Final do Arquivo Encontrado");
        } else {
            printk(KERN_ALERT "Conteúdo não Inicializado Anteriormente");
        }
    }
    return result;
}
\end{lstlisting}

% Algoritmo de Verificação -----------------------------------------------------
\subsection{Algoritmo de Verificação}
\label{subsec:algoritmo}

O Cadastro de Pessoa Física (CPF) e o Cadastro Nacional de Pessoa Jurídica
(CNPJ) são documentos que identificam pessoas junto à Receita Federal
brasileira. Estes documentos são formados por dígitos que podem ser validados
através da execução de um algoritmo posicional com pesos.

Para fins computacionais, podemos criar uma função que receba como entrada uma
sequência de caracteres e retorne uma confirmação se o valor é considerado um
documento do tipo CPF ou CNPJ válido. Estar válido não quer dizer existente,
somente que o documento informado passou sobre os testes de validação.

A função anteriormente definida deve ser acrescentada aos protótipos do
programa. Adicionando ao final do documento, vamos criar uma função que crie
esta validação sobre os dados apresentados. Como não temos como contar o tamanho
da entrada, vamos também apresentar esta informação como parâmetro, facilitando
inclusive na verificação do tipo de documento.


\begin{lstlisting}[caption={Inicialização do Algoritmo}]
// Protótipos
char verifier_document(char*,int);

// Função Inicializada
char verifier_document(char* content, int size) {
    return VERIFIER_SUCCESS;
}
\end{lstlisting}

Podemos conferir a utilização de definições anteriormente apresentadas,
fornecendo o caso de sucesso no início deste desenvolvimento. Outras definições
vão ser utilizadas no decorrer do desenvolvimento desta função. Um CNPJ possui
tamanho fixo de 14 caracteres numéricos retirando a máscara de formatação. Já o
CPF possui apenas 11 caracteres.

Primeiramente vamos inicializar as variáveis utilizadas no escopo da função.
Podemos conferir que existe uma variável que armazena os modificadores de
execução. Estes valores são os pesos que devem ser aplicados às posições do
número do documento.

\begin{lstlisting}[caption={Modificadores de Pesos}]
// Variáveis
int index; // Chave para Iterações
int comparison; // Comparações Variadas
// Modificadores
int* modifiers;
int modifiers_cpf[]  = {11,10,9,8,7,6,5,4,3,2};
int modifiers_cnpj[] = {6,5,4,3,2,9,8,7,6,5,4,3,2};
\end{lstlisting}

Logo no início da programação, verificamos se o conteúdo apresentado possui
tamanho fixo de 11 ou 14 caracteres, atribuindo os modificadores à variável
correta para processamento. Caso estes dois primeiros requisitos não são
válidos, vamos retornar uma falha de verificação.

\begin{lstlisting}[caption={Tamanho da Entrada}]
// Verificar Tamanho CPF ou CNPJ
if (size == 11) {
    // Modificadores para CPF
    modifiers = modifiers_cpf;
} else if (size == 14) {
    // Modificadores para CNPJ
    modifiers = modifiers_cnpj;
} else {
    // Tamanho Inválido
    printk(KERN_ALERT "Tamanho do Documento Inválido");
    return VERIFIER_FAIL;
}
\end{lstlisting}

Logo após vamos executar um laço de repetição para o conteúdo apresentado,
verificando se existem somente caracteres númericos. Logo após, executamos uma
tarefa considerada como expansão de caracteres, checando se todos os caracteres
são idênticos. O algoritmo fornece como correto todo documento que possui todos
os dígitos iguais, portanto precisamos executar esta tarefa separadamente.


\begin{lstlisting}[caption={Verificação de Dígitos e suas Expansões}]
// Verificar Conteúdo com Números Somente
for (index = 0; index < size; index = index + 1) {
    // Buscar no Intervalo [0-9]
    if (content[index] < '0' || content[index] > '9') {
        printk(KERN_ALERT "Documento Necessita Somente Números");
        return VERIFIER_FAIL;
    }
}

// Verificar Dígitos Expandidos
comparison = 1; // Confirmação Inicial
for (index = 0; index < size; index = index + 1) {
    comparison = comparison && (content[0] == content[index]);
}
if (comparison) {
    // Todos Dígitos Idênticos
    printk(KERN_ALERT "Documento com Dígitos Idênticos");
    return VERIFIER_FAIL;
}
\end{lstlisting}

Agora podemos executar o algoritmo de verificação de posicionamento com pesos.
A execução da tarefa é idêntica para ambos os números de documento, porém a
quantidade de pesos e seus valores são diferentes.

Cada posição recebe um peso até o antepenúltimo número, sendo que efetuamos o
somatório da multiplicação dos pesos com a posição. Se o resto da divisão por 11
neste somatório for inferior a 2, devemos apresentar 0 como resultado; caso
contrário, devemos apresentar o complemento deste resto sobre 11. Para
comparação, vamos adicionar 48 unidades ao conteúdo da posição para fins de
verificação, manipulando o resultado como uma conversão alfanumérica para
inteiro, utilizando a tabela ASCII. O caractere encontrado deve ser idêntico ao
penúltimo caractere, finalizando a verificação de primeiro nível.

A verificação de segundo nível é executada da mesma maneira, porém até a
penúltima posição do conteúdo. O resultado encontrado deve ser conferido com o
último caractere.

\begin{lstlisting}[caption={Aplicação dos Pesos}]
// Verificação com Modificadores Nível 1
comparison = 0;
for (index = 1; index < size - 1; index = index + 1) {
    comparison = comparison + modifiers[index] * (content[index - 1] - 48); // Conversão ATOI
}
printk(KERN_DEBUG "Comparação Nível 1 Somatório: %d", comparison);
comparison = comparison % 11;
comparison = (comparison < 2 ? 0 : 11 - comparison) + 48; // Conversão ITOA
if (comparison != content[size - 2]) {
    printk(KERN_ALERT "Verificação de Primeiro Nível Inválida");
    return VERIFIER_FAIL;
}

// Verificação com Modificadores Nível 2
comparison = 0;
for (index = 0; index < size - 1; index = index + 1) {
    comparison = comparison + modifiers[index] * (content[index] - 48); // Conversão ATOI
}
printk(KERN_DEBUG "Comparação Nível 2 Somatório: %d", comparison);
comparison = comparison % 11;
comparison = (comparison < 2 ? 0 : 11 - comparison) + 48; // Conversão ITOA
if (comparison != content[size - 1]) {
    printk(KERN_ALERT "Verificação de Segundo Nível Inválida");
    return VERIFIER_FAIL;
}
\end{lstlisting}

Se tudo ocorrer corretamente, podemos considerar o conteúdo do documento como um
CPF ou CNPJ válido, apresentando a definição de sucesso como retorno da função.

\begin{lstlisting}[caption={Aplicação dos Pesos}]
printk(KERN_INFO "Verificação do Documento com Sucesso");
return VERIFIER_SUCCESS;
\end{lstlisting}

Após o término do desenvolvimento desta função, podemos instalar o módulo no
Sistema Operacional utilizando o \textit{script} de instalação anteriormente
desenvolvido. Este executável irá adicionar um dispositivo de caractere e irá
instalar o módulo como um \textit{driver} para o mesmo. Agora podemos criar um
caso de teste para utilização.

% Testes -----------------------------------------------------------------------
\section{Testes}
\label{sec:testes}

Como anteriormente descrito, o módulo para verificação de documentos do tipo CPF
e CNPJ trabalha com dois passos distintos, escrita de determinado conteúdo no
dispositivo de caractere que identifica o documento. Após, durante a leitura,
receberemos como resposta um caractere 0 se o resultado esperado estiver
correto, caso contrário será retornado o caractere 1.

Isto tambem pode ser executado com dígitos que simbolizam documentos do tipo
CNPJ da mesma forma. O tipo de documento é verificado pela quantidade de
caracteres apresentados para verificação.

\begin{lstlisting}[caption={Testes com Sucesso},language=sh]
echo 72875866818 > /dev/verifier # Escrita com Sucesso
cat /dev/verifier # Resultado Esperado: 0
echo 29656444000161 > /dev/verifier # Escrita com Suceso
cat /dev/verifier # Resultado Esperado: 0
\end{lstlisting}

Podemos forçar o erro ao informar um número de documento inválido para o
algoritmo, como quantidade de caracteres diferente, números expandidos,
caracteres inválidos ou documento não reconhecido.

\begin{lstlisting}[caption={Testes com Falha},language=sh]
echo 12345 > /dev/verifier # Quantidade de Caracteres
cat /dev/verifier # Resultado Esperado: 1
echo 11111111111 > /dev/verifier # Expansão Numérica
cat /dev/verifier # Resultado Esperado: 1
echo abcd > /dev/verifier # Caracteres Inválidos
cat /dev/verifier # Resultado Esperado: 1
echo 72875866817 > /dev/verifier # Não Reconhecido
cat /dev/verifier # Resultado Esperado: 1
\end{lstlisting}

Caso alguma verificação seja solicitada se não existe um conteúdo para
manipulação no dispositivo de caractere, um erro de entrada e saída é
apresentado durante a leitura.

\begin{lstlisting}[caption={Testes com Erro de Entrada e Saída},language=sh]
cat /dev/verifier # Erro de Entrada e Saída
cat: /dev/verifier: Input/output error
\end{lstlisting}

% Problemas Encontrados --------------------------------------------------------
\section{Problemas Encontrados}
\label{sec:problemas}

O \textit{driver} para o dispositivo de caractere não trabalha de alguma forma
com prevenção de solicitações paralelas. Dois processos podem concorrentemente
acessar o dispositivo e causar um problema de entrada e saída, onde o primeiro
irá fornecer um conteúdo e o segundo logo após. Quando o primeiro solicitar a
verificação, a resposta será do segundo processo. Já quando o segundo processo
efetuar a leitura, teremos um problema de entrada e saída.

Isto pode ser executado com algum tipo de verificação atômica ou com
fornecimento de algum tipo de verificador que pode ser apresentado durante a
leitura, como tabela \textit{hash} para o identificador do processo que está
solicitando a verificação.

Outro problema é que dois dispositivos não podem acessar ao mesmo tempo a
verificadora, causando problemas desconhecidos. Se um processo executou a tarefa
de abertura de descritor para o dispositivo, outro processo não pode ter esta
tarefa. Isto poderia ser resolvido marcando o dispositivo como arquivo
previamente aberto, apresentando algum aviso quando houver tentativa de leitura
ou escrita.

% Finalização ------------------------------------------------------------------
\section{Finalização}
\label{sec:finalizacao}

O desenvolvimento de um módulo para o Kernel do Linux parece ser complicado logo
no início, principalmente por não fornecer as bibliotecas padrão da linguagem C.
Muitas execuções necessitam ser processadas de uma forma mais baixo nível do que
já conhecemos.  Também temos que ter o cuidado de retirar todas as alocações de
recursos de forma correta, como posições de memória inicializadas e reservadas
para o Kernel.

A criação de um dispositivo virtual capaz de verificar se um documento do tipo
CPF ou CNPJ é válido pode trazer início ao desenvolvimento de um \textit{driver}
real para leitoras destes tipos de documento. Também poderão ser criados
\textit{drivers} para dispositivos verificadores de boleto ou catracas
eletrônicas, por exemplo.

\bibliographystyle{sbc}
\bibliography{document}

\end{document}
