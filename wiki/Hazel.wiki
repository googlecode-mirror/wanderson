#summary Hazel Zend Framework Extended Library
#labels Phase-Requirements

= Hazel =

Esta página visa documentar a biblioteca Hazel (Hazel Zend Framework Extended
Library), que busca especializar as classes de desenvolvimento do Zend
Framework. _Esta documentação está incompleta e carece de informações_.

== Hazel_Controller ==

O pacote de controle do Hazel trabalha com especializações para manipulação de
objetos provenientes do banco de dados. Se existe uma entidade no banco de dados
que pode ser trabalhada através do padrão CRUD, utilizando um formulário e uma
tabela somente, a classe {{{Hazel_Controller_DatabaseCrudAbstract}}} pode ser
extendida. Esta classe possui as ações padrão para edição e toda a programação
necessária para edição simples das informações.

A idéia principal da classe é que toda a programação seja encapsulada nas
controladoras e caso seja necessário a modificação de alguns métodos, estes
consigam ser sobrescritos, afetando ao mínimo o fluxo de processamento; ou sejam
adicionados métodos nas classes de formulário e tabela, dando flexibilidade à
programação.

Para exemplificar, temos a seguinte tabela de usuários de um sistema, criada em
banco de dados PostgreSQL:

{{{
-- migration usuario-up 10 lines
CREATE TABLE usuario
(
    idusuario SERIAL NOT NULL,
    display   VARCHAR(40),
    nome      VARCHAR(20) NOT NULL UNIQUE,
    senha     CHAR(32) NOT NULL,
    ativado   BOOLEAN DEFAULT TRUE,
    deletado  BOOLEAN DEFAULT FALSE,
    PRIMARY KEY(idusuario)
);
}}}

Podemos criar uma classe representante desta tabela utilizando o padrão de
aplicativos do Zend Framework:

{{{
<?php

/**
 * Tabela de Usuários
 * @author Wanderson Henrique Camargo Rosa
 * @see    APPLICATION_PATH /model/DbTable/Usuario.php
 */
class Application_Model_DbTable_Usuario extends Zend_Db_Table_Usuario
{
    protected $_name = 'usuario';
}
}}}

Também vamos criar um formulário para edição destes dados para uma tupla da
tabela:

{{{
<?php

/**
 * Formulário de Usuário
 * @author Wanderson Henrique Camargo Rosa
 * @see    APPLICATION_PATH /forms/Usuario.php
 */
class Application_Form_Usuario extends Zend_Dojo_Form
{
    public function init()
    {
        $idusuario = new Zend_Form_Element_Hidden('idusuario');
        $idusuario->loadDefaultDecorators();
        $idusuario->removeDecorator('Label')->setRequired(true)
            ->addFilter(new Zend_Filter_Int())
            ->addFilter(new Zend_Filter_Null());

        $display = new Zend_Dojo_Form_Element_TextBox('display');
        $display->setLabel('Nome Completo')->setRequired(true)
            ->setAllowEmpty(true)->addFilter(new Zend_Filter_Null())
            ->addValidator(new Zend_Validate_StringLength(1,40))
            ->addValidator(new Zend_Validate_Alnum(true));

        $nome = new Zend_Dojo_Form_Element_TextBox('nome');
        $nome->setLabel('Usuário')->setRequired(true)->setAllowEmpty(false)
            ->addValidator(new Zend_Validate_NotEmpty())
            ->addValidator(new Zend_Validate_StringLength(1,20))
            ->addValidator(new Zend_Validate_Alpha(false))
            ->addFilter(new Zend_Filter_StringToLower());

        $senha = new Zend_Dojo_Form_Element_PasswordTextBox('senha');
        $senha->setLabel('Senha')->setRequired(false)->setAllowEmpty(true);

        $ativado = new Zend_Dojo_Form_Element_CheckBox('ativado');
        $ativado->setLabel('Ativado')->addFilter(new Zend_Filter_Boolean());

        $submit = new Zend_Dojo_Form_Element_SubmitButton('submit');
        $submit->setLabel('Gravar')->setIgnore(true);

        $elements = array($idusuario, $display, $nome, $senha, $ativado,
            $submit);

        $this->addElements($elements)->setName('usuario')
            ->setMethod(self::METHOD_POST);
    }
}
}}}

Para estes dados, podemos construir o controle de usuários da seguinte forma:

{{{

/**
 * Controle de Usuários
 * @author Wanderson Henrique Camargo Rosa
 * @see    APPLICATION_PATH /controllers/UsuarioController.php
 */
class UsuarioController extends Hazel_Controller_DatabaseCrudAbstract
{
}
}}}

Quando a classe é extendida, métodos representantes do padrão CRUD são criados
no controle para manipulação dos dados. Lembramos que o nome do formulário e da
tabela devem seguir o padrão do nome da controladora para que sejam
automaticamente carregados. Se precisamos de um controle de {{{Musica}}},
devemos criar a classe de controle {{{MusicaController}}}, o formulário
{{{Application_Form_Musica}}} e a representante de tabela
{{{Application_Model_DbTable_Musica}}}. Não há problemas quando estas classes
são criadas em módulos: a classe do Hazel pesquisa corretamente os locais. Se
temos o módulo {{{Servico}}} e o controle de {{{Servico_RelatorioController}}},
necessitamos criar o formulário {{{Servico_Form_Relatorio}}} e a representante
da tabela {{{Servico_Model_DbTable_Relatorio}}}.