#summary Hazel Zend Framework Extended Library
#labels Phase-Requirements

= Hazel =

Esta página visa documentar a biblioteca Hazel (Hazel Zend Framework Extended
Library), que busca especializar as classes de desenvolvimento do Zend
Framework. _Esta documentação está incompleta e carece de informações_.

== Hazel_Controller ==

Pacote http://code.google.com/p/wanderson/source/browse/trunk/Hazel/Controller/

O pacote de controle do Hazel trabalha com especializações para manipulação de
objetos provenientes do banco de dados. Se existe uma entidade no banco de dados
que pode ser trabalhada através do padrão CRUD, utilizando um formulário e uma
tabela somente, a classe {{{Hazel_Controller_DatabaseCrudAbstract}}} pode ser
extendida. Esta classe possui as ações padrão para edição e toda a programação
necessária para edição simples das informações.

A idéia principal da classe é que toda a programação seja encapsulada nas
controladoras e caso seja necessário a modificação de alguns métodos, estes
consigam ser sobrescritos, afetando ao mínimo o fluxo de processamento; ou sejam
adicionados métodos nas classes de formulário e tabela, dando flexibilidade à
programação.

Para exemplificar, temos a seguinte tabela de usuários de um sistema, criada em
banco de dados PostgreSQL:

{{{
-- migration usuario-up 10 lines
CREATE TABLE usuario
(
    idusuario SERIAL NOT NULL,
    display   VARCHAR(40),
    nome      VARCHAR(20) NOT NULL UNIQUE,
    senha     CHAR(32) NOT NULL,
    ativado   BOOLEAN DEFAULT TRUE,
    deletado  BOOLEAN DEFAULT FALSE,
    PRIMARY KEY(idusuario)
);
}}}

Podemos criar uma classe representante desta tabela utilizando o padrão de
aplicativos do Zend Framework:

{{{
<?php

/**
 * Tabela de Usuários
 * @author Wanderson Henrique Camargo Rosa
 * @see    APPLICATION_PATH /model/DbTable/Usuario.php
 */
class Application_Model_DbTable_Usuario extends Zend_Db_Table_Usuario
{
    protected $_name = 'usuario';
}
}}}

Também vamos criar um formulário para edição destes dados para uma tupla da
tabela:

{{{
<?php

/**
 * Formulário de Usuário
 * @author Wanderson Henrique Camargo Rosa
 * @see    APPLICATION_PATH /forms/Usuario.php
 */
class Application_Form_Usuario extends Zend_Dojo_Form
{
    public function init()
    {
        $idusuario = new Zend_Form_Element_Hidden('idusuario');
        $idusuario->loadDefaultDecorators();
        $idusuario->removeDecorator('Label')->setRequired(true)
            ->addFilter(new Zend_Filter_Int())
            ->addFilter(new Zend_Filter_Null());

        $display = new Zend_Dojo_Form_Element_TextBox('display');
        $display->setLabel('Nome Completo')->setRequired(true)
            ->setAllowEmpty(true)->addFilter(new Zend_Filter_Null())
            ->addValidator(new Zend_Validate_StringLength(1,40))
            ->addValidator(new Zend_Validate_Alnum(true));

        $nome = new Zend_Dojo_Form_Element_TextBox('nome');
        $nome->setLabel('Usuário')->setRequired(true)->setAllowEmpty(false)
            ->addValidator(new Zend_Validate_NotEmpty())
            ->addValidator(new Zend_Validate_StringLength(1,20))
            ->addValidator(new Zend_Validate_Alpha(false))
            ->addFilter(new Zend_Filter_StringToLower());

        $senha = new Zend_Dojo_Form_Element_PasswordTextBox('senha');
        $senha->setLabel('Senha')->setRequired(false)->setAllowEmpty(true);

        $ativado = new Zend_Dojo_Form_Element_CheckBox('ativado');
        $ativado->setLabel('Ativado')->addFilter(new Zend_Filter_Boolean());

        $submit = new Zend_Dojo_Form_Element_SubmitButton('submit');
        $submit->setLabel('Gravar')->setIgnore(true);

        $elements = array($idusuario, $display, $nome, $senha, $ativado,
            $submit);

        $this->addElements($elements)->setName('usuario')
            ->setMethod(self::METHOD_POST);
    }
}
}}}

Para estes dados, podemos construir o controle de usuários da seguinte forma:

{{{

/**
 * Controle de Usuários
 * @author Wanderson Henrique Camargo Rosa
 * @see    APPLICATION_PATH /controllers/UsuarioController.php
 */
class UsuarioController extends Hazel_Controller_DatabaseCrudAbstract
{
}
}}}

Quando a classe é extendida, métodos representantes do padrão CRUD são criados
no controle para manipulação dos dados. Lembramos que o nome do formulário e da
tabela devem seguir o padrão do nome da controladora para que sejam
automaticamente carregados. Se precisamos de um controle de {{{Musica}}},
devemos criar a classe de controle {{{MusicaController}}}, o formulário
{{{Application_Form_Musica}}} e a representante de tabela
{{{Application_Model_DbTable_Musica}}}. Não há problemas quando estas classes
são criadas em módulos: a classe do Hazel pesquisa corretamente os locais. Se
temos o módulo {{{Servico}}} e o controle de {{{Servico_RelatorioController}}},
necessitamos criar o formulário {{{Servico_Form_Relatorio}}} e a representante
da tabela {{{Servico_Model_DbTable_Relatorio}}}.

Ainda utilizando o exemplo de controle de {{{Usuario}}}, devemos criar as
visualizações, que não são executadas automaticamente para que seja possível a
renderização especializada, como o {{{Zend_View_Helper_PaginationControl}}}.

Um modelo de visualização de dados em tabela pode ser construído para a ação
{{{retrieve}}} do controle de {{{Usuario}}} da seguinte maneira:

{{{
<!-- @see APPLICATION_PATH /views/scripts/datagrid.phtml -->
<?php $address = array('action' => 'retrieve') ?>
<?php foreach ($this->primaries as $primary) : ?>
<?php $address[$primary] = null ?>
<?php endforeach ?>
<table>
    <tr>
<?php foreach ($this->columns as $column => $label) : ?>
        <th><a href="<?php echo $this->url(array_merge($address, array('order' => $column))) ?>"><?php echo $label?></a></th>
<?php endforeach ?>
        <th colspan="2"><a href="<?php echo $this->url(array_merge($address, array('action' => 'create', 'order' => null, 'page' => null))) ?>">Adicionar</a></th>
    </tr>
<?php if (count($this->result) > 0) : ?>
<?php foreach ($this->result as $element) : ?>
    <tr>
<?php foreach ($this->columns as $column => $label) : ?>
        <td><?php echo $element->$column ?></td>
<?php endforeach ?>
<?php $search = array('order' => null, 'page' => null) ?>
<?php foreach ($this->primaries as $primary) : ?>
<?php $search[$primary] = $element->$primary ?>
<?php endforeach ?>
        <td><a href="<?php echo $this->url(array_merge($search, array('action' => 'update'))) ?>">Visualizar</a></td>
        <td><a href="<?php echo $this->url(array_merge($search, array('action' => 'delete'))) ?>">Deletar</a></td>
    </tr>
<?php endforeach ?>
<?php else : ?>
    <tr>
        <td colspan="<?php echo count($this->columns) + 2 ?>">Lista Vazia</td>
    </tr>
<?php endif ?>
</table>
}}}

Este padrão de elementos em tabela é renderizado no arquivo {{{retrieve}}} da
camada de visualização utilizando método específico:

{{{
<!-- @see APPLICATION_PATH /views/scripts/usuario/retrieve.phtml -->
<?php echo $this->render('datagrid.phtml'); ?>
}}}

Os outros arquivos de visualização recebem o seguinte conteúdo de programação:

{{{
<!-- @see APPLICATION_PATH /views/scripts/usuario/create.phtml -->
<?php echo $this->form ?>
}}}

{{{
<!-- @see APPLICATION_PATH /views/scripts/usuario/update.phtml -->
<?php echo $this->form ?>
}}}

Não há encapsulamento destas execuções pois geralmente são necessários dados
adicionais referente ao conteúdo, sobre como um usuário deve ser adicionado ou
saída de dados que auxiliam o utilizador do sistema a trabalhar.