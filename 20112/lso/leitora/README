README
======

Este documento visa apresentar anotações sobre o que está sendo executado sobre
o desenvolvimento do Trabalho de Grau B para Laboratório de Sistemas
Operacionais, segundo semestre de 2012. Neste trabalho, vamos criar um driver
para um dispositivo de caractere como um módulo do kernel do Linux.

Recursos Necessários
--------------------

Para inicializar o desenvolvimento, precisamos do código fonte do próprio kernel
do Linux para utilização de seus headers. Em um sistema baseado em Debian,
podemos instalar esta dependência através do comando abaixo, com permissões de
superusuário.

[shell]
apt-get install linux-source
[/shell]

Como este é um metapacote, precisamos especificar qual código fonte do Linux
será instalado, conforme saída do comando acima. Atualmente, estou trabalhando
com a versão 2.6.32 do kernel. Logo, vamos instalar o código fonte com o comando
abaixo.

[shell]
apt-get install linux-source-2.6.32
[/shell]

Compilação
----------

Para facilitar a geração do módulo, quando instalamos o código fonte do kernel,
algumas ferramentas são instaladas. Porém, após uma pequena pesquisa na
documentação disponível, não encontrei nenhum tipo de explicação sobre o porquê
de utilizar os códigos descritos no Makefile. Após estudar o caso, encontrei
algumas explicações em sites e com testes. Temos o seguinte código interno ao
Makefile para utilizar o arquivo "main.c" como código fonte para geração do
código objeto "main.o".

[code file="Makefile"]
KVERSION   = $(shell uname -r)
KDIRECTORY = /lib/modules/$(KVERSION)/build

obj-m = main.o

all:
	make -C "$(KDIRECTORY)" "M=$(PWD)" modules

clean:
	make -C "$(KDIRECTORY)" "M=$(PWD)" clean
[/code]

As duas primeiras linhas são configurações para melhorar a criação do Makefile,
onde poderemos alterar diretamente estas opções caso necessário. A variável
"KVERSION" armazena a versão atual do kernel e "KDIRECTORY" armazena o caminho
dos arquivos necessários para criação do módulo e não dos arquivos de cabeçalho
utilizados no código fonte.

O conjunto de instruções com a etiqueta "all" constrói o código objeto do módulo
solicitado. O parâmetro "-C" modifica o diretório atual do "make" para o
"KDIRECTORY", que possui um outro "Makefile" configurado e especializado para
criar módulos do kernel. O parâmetro "M=" apresenta o diretório atual para o
"Makefile" interno ao "KDIRECTORY", que irá procurar pela opção "obj-m" para
gerar código objeto do módulo esperado. Esta configuração deve possuir o mesmo
nome do arquivo de código fonte com sufixo "*.o", representando a geração do
código objeto para aquele arquivo.

A opção *clean* limpa os arquivos gerados dentro do diretório atual,
intermediários ou resultantes da criação do objeto módulo previamente
construído.

Os dois comandos de terminal abaixo descrevem como gerar o código objeto e
limpar os arquivos gerados durante a execução desta tarefa, utilizando o comando
"make".

[shell]
make
make clean
[/shell]

A primeira linha apresenta a instrução que gera o código objeto "main.ko" que
representa o nosso módulo que poderá ser aplicado no kernel do Linux. A segunda
instrução limpa todos os arquivos gerados pela execução de criar o código
objeto, incluindo o próprio módulo gerado.

Exemplo Básico
--------------

Baseado em CORBET [2005], vamos construir um código fonte capaz de gerar um
módulo simples do Linux. As duas instruções necessárias para criar um módulo são
apresentadas: a que inicia o módulo junto ao kernel do Linux e a que é utilizada
para remover o módulo e desregistrar algumas funcionalidades inicializadas
anteriormente.

[code file="main.c"]
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void)
{
    printk(KERN_ALERT "Hello, World\n");
    return 0;
}

static void hello_exit(void)
{
    printk(KERN_ALERT "Goodbye, Cruel World\n");
}

module_init(hello_init);
module_exit(hello_exit);
[/code]

As duas primeiras linhas são necessárias para incluir os cabeçalhos de funções
de inicialização e de módulo, respectivamente. Durante a geração do código
objeto, os caminhos de inclusão são configurados pelo "Makefile" interno ao
diretório "KDIRECTORY" especificado anteriormente.

Após, a licença de utilização do módulo é apresentada. Esta chamada não é
necessária mas o seu conteúdo é apresentado quando utilizado o programa
*modinfo*, que exibe informações de um módulo ainda como um código objeto. A
chamada *MODULE_LICENSE* é uma macro e pode receber outros parâmetros, definidos
em "linux/module.h".

Basicamente, qualquer função pode ser considerada como inicialização ou
finalização de módulo, desde que obedeçam a sua assinatura. Funções de
inicialização não devem receber parâmetros e retornar um inteiro que representa
a execução com sucesso de sua inicialização. Da mesma forma, a função de
finalização não recebe parâmetros, porém não retorna valores. Estas funções
necessitam ser registradas utilizando as funções *module_init* e *module_exit*,
conforme a necessidade. Utilizando testes locais, as funções não necessitam ser
estáticas, conforme exemplo superior.

A função *printk* trabalha da mesma maneira que a função *printf*, porém em
espaço de kernel, já que as funções padrão do C não estão disponíveis. Podemos
verificar que não há concatenação da constante *KERN_ALERT* e o texto que deve
ser apresentado. Como uma *string* em C é uma cadeia de caracteres, o compilador
entende que duas *strings* lado a lado devem ser consideradas como únicas. Se há
uma separação por vírgula, a função *printk* recebe como primeiro parâmetro um
padrão para formatar a saída e os seguintes são considerados cada um como um
parâmetro deste padrão. Como não há nenhum padrão definido dentro de
*KERN_ALERT*, teremos uma mensagem de aviso em tempo de construção do código
objeto.

A constante *KERN_ALERT* apenas é uma *string* que informa o nível de
prioridade. Neste caso, o seu conteúdo representa o nível mais alto de aviso. O
seu conteúdo é somente um "<1>".

Por fim, a função *printk* é utilizada em ambas funções registradas,
representando a inserção e remoção do módulo do Linux. Agora veremos como
podemos gerenciar estes módulos diretamente no kernel.

Gerenciamento
-------------

O módulo gerado como código objeto pode ser inserido e removido do kernel do
Linux em tempo de execução. Para isto, vamos utilizar comandos específicos de
linha de comando como superusuário. Abaixo estão descritos os dois comandos que
inserem e removem o módulo anteriormente desenvolvido. Precisamos executar o
*make* e utilizar o arquivo *main.ko*, módulo gerado.

[shell]
insmod main.ko
rmmod main.ko
[/shell]

Dependendo da configuração que estamos utilizando e o ambiente de execução, como
janelas em ambientes gráficos, não vamos visualizar a saída esperada das funções
*printk*. Neste caso, o conteúdo gerado é armazenado em arquivos de *log* do
sistema. CORBET informa que este conteúdo é enviado para o arquivo
"/var/logs/messages", porém no sistema Debian utilizado para desenvolver este
documento o conteúdo foi enviado para "/var/logs/kern.log".

Para fins de testes e verificar se a nossa saída está sendo enviada
corretamente durante as execuções de inserção e remoção do módulo, podemos antes
executar o comando "tail -f /var/logs/kern.log" para efetuar a leitura constante
do conteúdo armazenado no arquivo. Sempre que algo é armazenado neste, o comando
*tail* apresenta na saída padrão o conteúdo capturado.

Instalador Simples
------------------

Para auxiliar no desenvolvimento, deve ser criado um instalador simples que
facilita na manipulação do módulo dentro do sistema. Vamos criar algumas linhas
de configurações, inicializando variáveis num arquivo de código fonte no formato
Shellscript.

[shell file="install.sh"]
USERID=$(id -u)
DRIVER_NAME="verifier"
DEVICE_NAME="verifier"
[/shell]

Após devemos verificar se o usuário atual é o que possui uid (identificador do
usuário) igual a 0 (zero), ou seja, o usuário raiz do sistema.  Esta tarefa deve
ser executada sobre o número identificador porque seu nome pode ser modificado,
porém este valor não. Para auxiliar no tratamento de erro, criamos uma função
que formata uma saída e possui encapsulados uma execução de finalização.

[shell file="install.sh"]
function verifier_error() {
    echo ERROR: $1
    if [ ! -z $2 ]; then
        exit $2
    fi
}
if [ $USERID -ne 0 ]; then
    verifier_error "Necessário Usuário Raiz" 1
fi
[/shell]

Posteriormente, vamos inserir o módulo no kernel do Linux utilizando o comando
específico, esperando que sua execução tenha finalizado com sucesso. Caso
contrário, vamos gerar um erro dentro da instalação.

[shell file="install.sh"]
insmod "$DRIVER_NAME.ko"
if [ $? -ne 0 ]; then
    verifier_error "Impossível Instalar Módulo" 2
fi
[/shell]

Como o nosso módulo possui uma criação dinâmica de número maior, devemos
capturar este valor do conteúdo armazenado no arquivo com dispositivos do
sistema. Se ele não existir ou não estiver sido encontrado, também vamos gerar
um erro e finalizar a execução com uma saída diferente de zero.

[shell file="install.sh"]
MAJOR=$(grep "$DRIVER_NAME" /proc/devices | cut -d' ' -f1)
if [ -z $MAJOR ]; then
    verifier_error "Impossível Encontrar Número Maior" 3
fi
[/shell]

Finalizando, vamos remover qualquer tipo de dispositivo com o mesmo nome,
previamente criado e adicionar o nosso dispositivo de caractere com o mesmo
número maior do módulo adicionado anteriormente. No nosso caso, o número menor
não é significativo, portanto vamos configurá-lo com valor zero. Finalizamos o
instalador com uma saída igual a zero, demonstrando sucesso de execução.

[shell file="install.sh"]
rm -f "/dev/$DEVICE_NAME"
mknod "/dev/$DEVICE_NAME" c "$MAJOR" 0
chmod 666 "/dev/$DEVICE_NAME"
exit 0
[/shell]
