README
======

Este documento visa apresentar anotações sobre o que está sendo executado sobre
o desenvolvimento do Trabalho de Grau B para Laboratório de Sistemas
Operacionais, segundo semestre de 2012. Neste trabalho, vamos criar um driver
para um dispositivo de caractere como um módulo do kernel do Linux.

Recursos Necessários
--------------------

Para inicializar o desenvolvimento, precisamos do código fonte do próprio kernel
do Linux para utilização de seus headers. Em um sistema baseado em Debian,
podemos instalar esta dependência através do comando abaixo, com permissões de
superusuário.

[shell]
apt-get install linux-source
[/shell]

Como este é um metapacote, precisamos especificar qual código fonte do Linux
será instalado, conforme saída do comando acima. Atualmente, estou trabalhando
com a versão 2.6.32 do kernel. Logo, vamos instalar o código fonte com o comando
abaixo.

[shell]
apt-get install linux-source-2.6.32
[/shell]

Compilação
----------

Para facilitar a geração do módulo, quando instalamos o código fonte do kernel,
algumas ferramentas são instaladas. Porém, após uma pequena pesquisa na
documentação disponível, não encontrei nenhum tipo de explicação sobre o porquê
de utilizar os códigos descritos no Makefile. Após estudar o caso, encontrei
algumas explicações em sites e com testes. Temos o seguinte código interno ao
Makefile para utilizar o arquivo "main.c" como código fonte para geração do
código objeto "main.o".

[code file="Makefile"]
KVERSION   = $(shell uname -r)
KDIRECTORY = /lib/modules/$(KVERSION)/build

obj-m = main.o

all:
	make -C "$(KDIRECTORY)" "M=$(PWD)" modules

clean:
	make -C "$(KDIRECTORY)" "M=$(PWD)" clean
[/code]

As duas primeiras linhas são configurações para melhorar a criação do Makefile,
onde poderemos alterar diretamente estas opções caso necessário. A variável
"KVERSION" armazena a versão atual do kernel e "KDIRECTORY" armazena o caminho
dos arquivos necessários para criação do módulo e não dos arquivos de cabeçalho
utilizados no código fonte.

O conjunto de instruções com a etiqueta "all" constrói o código objeto do módulo
solicitado. O parâmetro "-C" modifica o diretório atual do "make" para o
"KDIRECTORY", que possui um outro "Makefile" configurado e especializado para
criar módulos do kernel. O parâmetro "M=" apresenta o diretório atual para o
"Makefile" interno ao "KDIRECTORY", que irá procurar pela opção "obj-m" para
gerar código objeto do módulo esperado. Esta configuração deve possuir o mesmo
nome do arquivo de código fonte com sufixo "*.o", representando a geração do
código objeto para aquele arquivo.

A opção *clean* limpa os arquivos gerados dentro do diretório atual,
intermediários ou resultantes da criação do objeto módulo previamente
construído.

Os dois comandos de terminal abaixo descrevem como gerar o código objeto e
limpar os arquivos gerados durante a execução desta tarefa, utilizando o comando
"make".

[shell]
make
make clean
[/shell]

A primeira linha apresenta a instrução que gera o código objeto "main.ko" que
representa o nosso módulo que poderá ser aplicado no kernel do Linux. A segunda
instrução limpa todos os arquivos gerados pela execução de criar o código
objeto, incluindo o próprio módulo gerado.

Exemplo Básico
--------------

Baseado em CORBET [2005], vamos construir um código fonte capaz de gerar um
módulo simples do Linux. As duas instruções necessárias para criar um módulo são
apresentadas: a que inicia o módulo junto ao kernel do Linux e a que é utilizada
para remover o módulo e desregistrar algumas funcionalidades inicializadas
anteriormente.

[code file="main.c"]
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void)
{
    printk(KERN_ALERT "Hello, World\n");
    return 0;
}

static void hello_exit(void)
{
    printk(KERN_ALERT "Goodbye, Cruel World\n");
}

module_init(hello_init);
module_exit(hello_exit);
[/code]

As duas primeiras linhas são necessárias para incluir os cabeçalhos de funções
de inicialização e de módulo, respectivamente. Durante a geração do código
objeto, os caminhos de inclusão são configurados pelo "Makefile" interno ao
diretório "KDIRECTORY" especificado anteriormente.

Após, a licença de utilização do módulo é apresentada. Esta chamada não é
necessária mas o seu conteúdo é apresentado quando utilizado o programa
*modinfo*, que exibe informações de um módulo ainda como um código objeto. A
chamada *MODULE_LICENSE* é uma macro e pode receber outros parâmetros, definidos
em "linux/module.h".

Basicamente, qualquer função pode ser considerada como inicialização ou
finalização de módulo, desde que obedeçam a sua assinatura. Funções de
inicialização não devem receber parâmetros e retornar um inteiro que representa
a execução com sucesso de sua inicialização. Da mesma forma, a função de
finalização não recebe parâmetros, porém não retorna valores. Estas funções
necessitam ser registradas utilizando as funções *module_init* e *module_exit*,
conforme a necessidade. Utilizando testes locais, as funções não necessitam ser
estáticas, conforme exemplo superior.

A função *printk* trabalha da mesma maneira que a função *printf*, porém em
espaço de kernel, já que as funções padrão do C não estão disponíveis. Podemos
verificar que não há concatenação da constante *KERN_ALERT* e o texto que deve
ser apresentado. Como uma *string* em C é uma cadeia de caracteres, o compilador
entende que duas *strings* lado a lado devem ser consideradas como únicas. Se há
uma separação por vírgula, a função *printk* recebe como primeiro parâmetro um
padrão para formatar a saída e os seguintes são considerados cada um como um
parâmetro deste padrão. Como não há nenhum padrão definido dentro de
*KERN_ALERT*, teremos uma mensagem de aviso em tempo de construção do código
objeto.

A constante *KERN_ALERT* apenas é uma *string* que informa o nível de
prioridade. Neste caso, o seu conteúdo representa o nível mais alto de aviso. O
seu conteúdo é somente um "<1>".

Por fim, a função *printk* é utilizada em ambas funções registradas,
representando a inserção e remoção do módulo do Linux. Agora veremos como
podemos gerenciar estes módulos diretamente no kernel.

Gerenciamento
-------------

O módulo gerado como código objeto pode ser inserido e removido do kernel do
Linux em tempo de execução. Para isto, vamos utilizar comandos específicos de
linha de comando como superusuário. Abaixo estão descritos os dois comandos que
inserem e removem o módulo anteriormente desenvolvido. Precisamos executar o
*make* e utilizar o arquivo *main.ko*, módulo gerado.

[shell]
insmod main.ko
rmmod main.ko
[/shell]

Dependendo da configuração que estamos utilizando e o ambiente de execução, como
janelas em ambientes gráficos, não vamos visualizar a saída esperada das funções
*printk*. Neste caso, o conteúdo gerado é armazenado em arquivos de *log* do
sistema. CORBET informa que este conteúdo é enviado para o arquivo
"/var/logs/messages", porém no sistema Debian utilizado para desenvolver este
documento o conteúdo foi enviado para "/var/logs/kern.log".

Para fins de testes e verificar se a nossa saída está sendo enviada
corretamente durante as execuções de inserção e remoção do módulo, podemos antes
executar o comando "tail -f /var/logs/kern.log" para efetuar a leitura constante
do conteúdo armazenado no arquivo. Sempre que algo é armazenado neste, o comando
*tail* apresenta na saída padrão o conteúdo capturado.

Instalador Simples
------------------

Para auxiliar no desenvolvimento, deve ser criado um instalador simples que
facilita na manipulação do módulo dentro do sistema. Vamos criar algumas linhas
de configurações, inicializando variáveis num arquivo de código fonte no formato
Shellscript.

[shell file="install.sh"]
USERID=$(id -u)
DRIVER_NAME="verifier"
DEVICE_NAME="verifier"
[/shell]

Após devemos verificar se o usuário atual é o que possui uid (identificador do
usuário) igual a 0 (zero), ou seja, o usuário raiz do sistema.  Esta tarefa deve
ser executada sobre o número identificador porque seu nome pode ser modificado,
porém este valor não. Para auxiliar no tratamento de erro, criamos uma função
que formata uma saída e possui encapsulados uma execução de finalização.

[shell file="install.sh"]
function verifier_error() {
    echo ERROR: $1
    if [ ! -z $2 ]; then
        exit $2
    fi
}
if [ $USERID -ne 0 ]; then
    verifier_error "Necessário Usuário Raiz" 1
fi
[/shell]

Posteriormente, vamos inserir o módulo no kernel do Linux utilizando o comando
específico, esperando que sua execução tenha finalizado com sucesso. Caso
contrário, vamos gerar um erro dentro da instalação.

[shell file="install.sh"]
insmod "$DRIVER_NAME.ko"
if [ $? -ne 0 ]; then
    verifier_error "Impossível Instalar Módulo" 2
fi
[/shell]

Como o nosso módulo possui uma criação dinâmica de número maior, devemos
capturar este valor do conteúdo armazenado no arquivo com dispositivos do
sistema. Se ele não existir ou não estiver sido encontrado, também vamos gerar
um erro e finalizar a execução com uma saída diferente de zero.

[shell file="install.sh"]
MAJOR=$(grep "$DRIVER_NAME" /proc/devices | cut -d' ' -f1)
if [ -z $MAJOR ]; then
    verifier_error "Impossível Encontrar Número Maior" 3
fi
[/shell]

Finalizando, vamos remover qualquer tipo de dispositivo com o mesmo nome,
previamente criado e adicionar o nosso dispositivo de caractere com o mesmo
número maior do módulo adicionado anteriormente. No nosso caso, o número menor
não é significativo, portanto vamos configurá-lo com valor zero. Finalizamos o
instalador com uma saída igual a zero, demonstrando sucesso de execução.

[shell file="install.sh"]
rm -f "/dev/$DEVICE_NAME"
mknod "/dev/$DEVICE_NAME" c "$MAJOR" 0
chmod 666 "/dev/$DEVICE_NAME"
exit 0
[/shell]

Verificadora
------------

Vamos inicializar o desenvolvimento da verificadora de CPF/CNPJ, base da
Proposta de Trabalho de Grau B para a disciplina de Laboratório de Sistemas
Operacionais. Precisamos inicialmente criar um módulo que consiga gerar um
"número maior" automaticamente, com base no código fonte apresentado por CORBET
[2005].

Logo nas primeiras linhas, vamos configurar as informações do módulo, acessíveis
dentro do sistema operacional utilizando a função *modinfo*. Informamos uma
pequena descrição do módulo e seus autores, bem como o número da versão atual e
a licença de utilização do mesmo. Abaixo, apenas definimos algumas constantes
para utilização dentro da programação do módulo, que serão resolvidas logo no
início pelo pré-compilador.

[code file="verifier.c"]
MODULE_DESCRIPTION("Driver para Verificadora de CPF e CNPJ");
MODULE_AUTHOR("Wanderson Henrique Camargo Rosa <wandersonwhcr@gmail.com>");
MODULE_AUTHOR("Jeferson Souza <jeferson.s.souza@hotmail.com>");
MODULE_AUTHOR("Bruno Fagundes <web@bfagundes.com>");
MODULE_VERSION("0.1b");
MODULE_LICENSE("Dual BSD/CPL");

#define DRIVER_NAME "verifier"
#define MINOR_NUMBER 0
#define DEVICE_COUNTER 1
[/code]

Vamos adicionar as assinaturas das duas primeiras funções que serão
desenvolvidas durante o processo. Logo abaixo, elas são registradas como
inicialização e finalização de módulo. Conforme necessário, estas funções
possuem assinaturas compatíveis com os registradores de funções.

[code file="verifier.c"]
int verifier_init(void);
void verifier_exit(void);

module_init(verifier_init);
module_exit(verifier_exit);
[/code]

Para manipulação, vamos inicializar uma variável global e interna ao módulo para
armazenar o número referente ao dispositivo alocado. Este dispositivo
corresponde ao criado e anexado com o número maior dentro do instalador. No
nosso caso, o dispositivo deverá se chamar "verifier" e será criado dentro do
diretório de dispositivos padrão. Ele deve ser alocado dentro da função de
inicialização do módulo. Adicionamos algumas mensagens que serão visualizadas
somente no arquivo descrito na seção inicial deste documento.

[code file="verifier.c"]
dev_t device;

int verifier_init(void) {
    int result;
    printk(KERN_INFO "Inicialização de Verificadora CPF/CNPJ");
    result = alloc_chrdev_region(&device, MINOR_NUMBER, DEVICE_COUNTER, DRIVER_NAME);
    if (result == 0) {
        printk(KERN_INFO "Inicialização com Sucesso");
    } else {
        printk(KERN_ALERT "Impossível Alocação de Dispositivo");
    }
    return result;
}
[/code]

Buscando alocar o módulo, utilizamos a função específica para alocar um
dispositivo sem a existência de um número maior sendo informado dentro do código
fonte. Para outros elementos, utilizamos nossas definições descritas. Devemos
também apresentar os resultados ao final de inicializar o módulo.

Já a função de finalização é desenvolvida de maneira mais simples, solicitando
uma retirada do registro de dispositivos alocados o nosso alocado na
inicialização. Para isto, somente precimos informar o próprio valor do
dispositivo e a quantidade de elementos que devem sofrer esta ação; definido
anteriormente, o número de dispositivos é 1 (um).

[code file="verifier.c"]
void verifier_exit(void) {
    printk(KERN_INFO "Finalização de Verificadora CPF/CNPJ");
    unregister_chrdev_region(device, DEVICE_COUNTER);
    printk(KERN_INFO "Finalização com Sucesso");
}
[/code]

Com isto, temos um módulo que aloca um dispositivo para manipulação, anexando-se
ao elemento através de um número maior. No nosso caso, o instalador captura o
número variado criado.

Temos então um pequeno módulo de kernel do Linux que aloca um determinado
dispositivo. Este módulo trabalha como um _driver_. Como vamos criar uma leitora
de dados, precisamos adicionar funções de abertura, leitura, escrita e
fechamento deste dispositivo de caracteres, gerando assim nosso módulo de
verificação de CPF e CNPJ.

Alocação no Sistema Operacional
===============================

Neste momento, vamos inicializar um dispositivo de caractere dentro do sistema
operacional, fornecendo as operações que devem ser executadas quando o
dispositivo é acessado.

Operações Sobre Arquivos
------------------------

Neste momento, precisamos implementar 4 tipos de operações básicas: abertura,
leitura, escrita e fechamento do dispositivo de caracteres. Portanto, precisamos
implementar 4 funções que executam esta tarefa e fornecer a uma estrutura com
esta responsabilidade dentro da programação. Na área de assinaturas de funções,
vamos fornecer os seguintes protótipos.

[code file="verifier.c"]
int verifier_open(struct inode*, struct file*);
ssize_t verifier_read(struct file*, char __user*, size_t, loff_t*);
ssize_t verifier_write(struct file*, const char __user*, size_t, loff_t*);
int verifier_release(struct inode*, struct file*);
[/code]

Cada uma destas inicializações possui as suas características. A função para
leitura recebe como primeiro parâmetro um ponteiro para estrutura do
representante do arquivo dentro do sistema operacional; o segundo parâmetro
identifica o mesmo arquivo, porém com informações de sua abertura. Logo, temos
que o *inode* apresenta informações sobre a estrutura física do arquivo e o
parâmetro *file* apresenta informações sobre os descritores inicializados para
este arquivo.

Para executar a leitura, a segunda função armazena todas as execuções para esta
finalidade. O primeiro parâmetro *file*, assim como durante a abertura,
representa o arquivo aberto dentro do sistema, com informações sobre os
descritores inicializados. Já o segundo parâmetro *__user* representa um
ponteiro do tipo caractere para região de memória em espaço de usuário. O
parâmetro *size_t* indica a quantidade de _bytes_ que devem ser fornecidos para
a leitura. O último parâmetro *loff_t* fornece a posição atual da leitura no
arquivo apresentado. Como retorno, temos a quantidade de caracteres processados
com sucesso.

Com base na estrutura de leitura, a escrita recebe as mesmas quantidades de
parâmetros com funcionalidades semelhantes, porém o terceiro parâmetro *__user*
define um ponteiro para a região de memória em espaço de usuário que armazena os
valores para processamento.

As funções de leitura e escrita possuem uma peculiaridade, o valor de retorno
que representa a quantidade de caracteres processados. Se a função retorna o
mesmo valor solicitado para o utilização, então toda a quantidade de elementos
apresentada foi processada. Já se o valor retornado é menor do que o solicitado,
então uma quantidade menor foi processada. Se o valor retornado é igual a zero,
o final do arquivo foi alcançado. Por último, se o valor retornado é negativo,
então houve um erro durante o processamento. Estes erros estão definidos em
*linux/errno.h".

A última função representa o fechamento do arquivo pelo sistema operacional.
Esta somente é utilizada se todos os descritores de todos os processos foram
finalizados com sucesso. Caso seja necessário algum processamento quando um
descritor somente é fechado, temos que utilizar a função *flush*, não definida
no escopo acima.

Definição de Operações
----------------------

Para que as operações sejam apresentadas ao dispositivo de caractere que será
alocado no sistema operacional, precisamos armazená-las em uma estrutura com
esta finalidade. Esta estrutura do tipo *file_operations* recebe ponteiros para
as funções definidas nos protótipos.

[code file="verifier.c"]
struct file_operations verifier_fops = {
    .read    = verifier_read,
    .write   = verifier_write,
    .open    = verifier_open,
    .release = verifier_release,
};
[/code]

Assim, temos uma estrutura de nome *verifier_fops* com os ponteiros devidamente
inicializados com as funções para manipulação de arquivos. Vale lembrar que
estas funções necessitam possuir os parâmetros necessários, característica de
sua tipagem. Este tipo de inicialização de estrutura corresponde ao formato C99.

Alocação do Dispositivo
-----------------------

Agora vamos alocar o dispositivo de caractere no sistema operacional, fornecendo
a estrutura de operações em arquivos definida anteriormente. Logo após a
confirmação de inicialização com sucesso do _driver_, vamos solicitar ao sistema
a alocação de um novo dispositivo de caractere.

[code file="verifier.c"]
// Definido como Global
struct cdev *cdevice;
// Estrutura de Inicialização
cdevice = cdev_alloc();
cdevice->ops = &verifier_fops;
result = cdev_add(cdevice, device, DEVICE_COUNTER);
[/code]

Com a devida alocação do dispositivo, apresentamos como operadores o endereço
para a estrutura com os operadores de arquivos definida anteriormente.  A
terceira linha tenta adicionar o dispositivo no sistema operacional, utilizando
como primeiro parâmetro o dispositivo alocado e segundo o dispositivo físico
inicializado com o _driver_. O último parâmetro representa a quantidade de
dispositivos que irão ser utilizados com esta alocação.

Vale lembrar que *cdevice* é uma variável global que está definida fora do
escopo das funções e pode ser acessada por qualquer uma delas, inclusive na
finalização do módulo, que precisa desalocar o recurso. Já a variável *device* e
a definição DEVICE_COUNTER foram criadas anteriormente, durante a inicialização
básica do módulo.

Novamente, vamos armazenar o resultado do processamento em *result* e criar um
tratamento de possível erro de alocação.

[code file="verifier.c"]
if (result == 0) {
    // Alocação com Sucesso
    printk(KERN_INFO "Alocação com Sucesso");
} else {
    // Alocação com Erros
    printk(KERN_ALERT "Impossível Alocar Dispositivo no Sistema");
}
[/code]

Agora precisamos desalocar a inicialização do dispositivo de caractere no
sistema operacional. Durante a finalização do módulo, antes de remover a região
disponibilizada para o dispositivo, vamos desalocar o dispositivo de caractere.

[code file="verifier.c"]
cdev_del(cdevice);
[/code]

Assim, temos o nosso dispositivo de caractere devidamente inicializado, bastando
escrever as funções com operações de arquivos que somente foram definidas como
protótipos.

Escrita de Operações
--------------------

As operações iniciais para arquivos devem ser definidas de forma bem simples,
somente para fornecer ao sistema operacional as devidas entradas. As próximas
seções do documento deverão discutir cada uma delas. Por hora, as funções de
abertura e fechamento retornam sucesso para qualquer solicitação; já as
responsáveis pela leitura e escrita somente apresentam a quantidade de _bytes_
processados e final de arquivo, respectivamente.

[code file="verifier.c"]
// Abertura
int verifier_open(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Abertura de Arquivo");
    return 0;
}
// Leitura
size_t verifier_read(struct file* filp, char __user* buffer, size_t count, loff_t* offp) {
    printk(KERN_DEBUG "Leitura em Arquivo");
    return count;
}
// Escrita
ssize_t verifier_write(struct file* filp, const char __user* buffer, size_t count, loff_t* offp) {
    printk(KERN_DEBUG "Escrita em Arquivo");
    return count;
}
// Fechamento
int verifier_release(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Fechamento de Arquivo");
    return 0;
}
[/code]

Como temos todas as inicializações para operações com arquivos devidamente
inicializadas, podemos começar o desenvolvimento da implementação da
verificadora de documentos do tipo CPF e CNPJ, proposta do Trabalho de Grau B
desta disciplina.
