README
======

Este documento visa apresentar anotações sobre o que está sendo executado sobre
o desenvolvimento do Trabalho de Grau B para Laboratório de Sistemas
Operacionais, segundo semestre de 2012. Neste trabalho, vamos criar um driver
para um dispositivo de caractere como um módulo do kernel do Linux.

Recursos Necessários
--------------------

Para inicializar o desenvolvimento, precisamos do código fonte do próprio kernel
do Linux para utilização de seus headers. Em um sistema baseado em Debian,
podemos instalar esta dependência através do comando abaixo, com permissões de
superusuário.

[shell]
apt-get install linux-source
[/shell]

Como este é um metapacote, precisamos especificar qual código fonte do Linux
será instalado, conforme saída do comando acima. Atualmente, estou trabalhando
com a versão 2.6.32 do kernel. Logo, vamos instalar o código fonte com o comando
abaixo.

[shell]
apt-get install linux-source-2.6.32
[/shell]

Compilação
----------

Para facilitar a geração do módulo, quando instalamos o código fonte do kernel,
algumas ferramentas são instaladas. Porém, após uma pequena pesquisa na
documentação disponível, não encontrei nenhum tipo de explicação sobre o porquê
de utilizar os códigos descritos no Makefile. Após estudar o caso, encontrei
algumas explicações em sites e com testes. Temos o seguinte código interno ao
Makefile para utilizar o arquivo "main.c" como código fonte para geração do
código objeto "main.o".

[code file="Makefile"]
KVERSION   = $(shell uname -r)
KDIRECTORY = /lib/modules/$(KVERSION)/build

obj-m = main.o

all:
	make -C "$(KDIRECTORY)" "M=$(PWD)" modules

clean:
	make -C "$(KDIRECTORY)" "M=$(PWD)" clean
[/code]

As duas primeiras linhas são configurações para melhorar a criação do Makefile,
onde poderemos alterar diretamente estas opções caso necessário. A variável
"KVERSION" armazena a versão atual do kernel e "KDIRECTORY" armazena o caminho
dos arquivos necessários para criação do módulo e não dos arquivos de cabeçalho
utilizados no código fonte.

O conjunto de instruções com a etiqueta "all" constrói o código objeto do módulo
solicitado. O parâmetro "-C" modifica o diretório atual do "make" para o
"KDIRECTORY", que possui um outro "Makefile" configurado e especializado para
criar módulos do kernel. O parâmetro "M=" apresenta o diretório atual para o
"Makefile" interno ao "KDIRECTORY", que irá procurar pela opção "obj-m" para
gerar código objeto do módulo esperado. Esta configuração deve possuir o mesmo
nome do arquivo de código fonte com sufixo "*.o", representando a geração do
código objeto para aquele arquivo.

A opção *clean* limpa os arquivos gerados dentro do diretório atual,
intermediários ou resultantes da criação do objeto módulo previamente
construído.

Os dois comandos de terminal abaixo descrevem como gerar o código objeto e
limpar os arquivos gerados durante a execução desta tarefa, utilizando o comando
"make".

[shell]
make
make clean
[/shell]

A primeira linha apresenta a instrução que gera o código objeto "main.ko" que
representa o nosso módulo que poderá ser aplicado no kernel do Linux. A segunda
instrução limpa todos os arquivos gerados pela execução de criar o código
objeto, incluindo o próprio módulo gerado.

Exemplo Básico
--------------

Baseado em CORBET [2005], vamos construir um código fonte capaz de gerar um
módulo simples do Linux. As duas instruções necessárias para criar um módulo são
apresentadas: a que inicia o módulo junto ao kernel do Linux e a que é utilizada
para remover o módulo e desregistrar algumas funcionalidades inicializadas
anteriormente.

[code file="main.c"]
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void)
{
    printk(KERN_ALERT "Hello, World\n");
    return 0;
}

static void hello_exit(void)
{
    printk(KERN_ALERT "Goodbye, Cruel World\n");
}

module_init(hello_init);
module_exit(hello_exit);
[/code]

As duas primeiras linhas são necessárias para incluir os cabeçalhos de funções
de inicialização e de módulo, respectivamente. Durante a geração do código
objeto, os caminhos de inclusão são configurados pelo "Makefile" interno ao
diretório "KDIRECTORY" especificado anteriormente.

Após, a licença de utilização do módulo é apresentada. Esta chamada não é
necessária mas o seu conteúdo é apresentado quando utilizado o programa
*modinfo*, que exibe informações de um módulo ainda como um código objeto. A
chamada *MODULE_LICENSE* é uma macro e pode receber outros parâmetros, definidos
em "linux/module.h".

Basicamente, qualquer função pode ser considerada como inicialização ou
finalização de módulo, desde que obedeçam a sua assinatura. Funções de
inicialização não devem receber parâmetros e retornar um inteiro que representa
a execução com sucesso de sua inicialização. Da mesma forma, a função de
finalização não recebe parâmetros, porém não retorna valores. Estas funções
necessitam ser registradas utilizando as funções *module_init* e *module_exit*,
conforme a necessidade. Utilizando testes locais, as funções não necessitam ser
estáticas, conforme exemplo superior.

A função *printk* trabalha da mesma maneira que a função *printf*, porém em
espaço de kernel, já que as funções padrão do C não estão disponíveis. Podemos
verificar que não há concatenação da constante *KERN_ALERT* e o texto que deve
ser apresentado. Como uma *string* em C é uma cadeia de caracteres, o compilador
entende que duas *strings* lado a lado devem ser consideradas como únicas. Se há
uma separação por vírgula, a função *printk* recebe como primeiro parâmetro um
padrão para formatar a saída e os seguintes são considerados cada um como um
parâmetro deste padrão. Como não há nenhum padrão definido dentro de
*KERN_ALERT*, teremos uma mensagem de aviso em tempo de construção do código
objeto.

A constante *KERN_ALERT* apenas é uma *string* que informa o nível de
prioridade. Neste caso, o seu conteúdo representa o nível mais alto de aviso. O
seu conteúdo é somente um "<1>".

Por fim, a função *printk* é utilizada em ambas funções registradas,
representando a inserção e remoção do módulo do Linux. Agora veremos como
podemos gerenciar estes módulos diretamente no kernel.

Gerenciamento
-------------

O módulo gerado como código objeto pode ser inserido e removido do kernel do
Linux em tempo de execução. Para isto, vamos utilizar comandos específicos de
linha de comando como superusuário. Abaixo estão descritos os dois comandos que
inserem e removem o módulo anteriormente desenvolvido. Precisamos executar o
*make* e utilizar o arquivo *main.ko*, módulo gerado.

[shell]
insmod main.ko
rmmod main.ko
[/shell]

Dependendo da configuração que estamos utilizando e o ambiente de execução, como
janelas em ambientes gráficos, não vamos visualizar a saída esperada das funções
*printk*. Neste caso, o conteúdo gerado é armazenado em arquivos de *log* do
sistema. CORBET informa que este conteúdo é enviado para o arquivo
"/var/logs/messages", porém no sistema Debian utilizado para desenvolver este
documento o conteúdo foi enviado para "/var/logs/kern.log".

Para fins de testes e verificar se a nossa saída está sendo enviada
corretamente durante as execuções de inserção e remoção do módulo, podemos antes
executar o comando "tail -f /var/logs/kern.log" para efetuar a leitura constante
do conteúdo armazenado no arquivo. Sempre que algo é armazenado neste, o comando
*tail* apresenta na saída padrão o conteúdo capturado.

Instalador Simples
------------------

Para auxiliar no desenvolvimento, deve ser criado um instalador simples que
facilita na manipulação do módulo dentro do sistema. Vamos criar algumas linhas
de configurações, inicializando variáveis num arquivo de código fonte no formato
Shellscript.

[shell file="install.sh"]
USERID=$(id -u)
DRIVER_NAME="verifier"
DEVICE_NAME="verifier"
[/shell]

Após devemos verificar se o usuário atual é o que possui uid (identificador do
usuário) igual a 0 (zero), ou seja, o usuário raiz do sistema.  Esta tarefa deve
ser executada sobre o número identificador porque seu nome pode ser modificado,
porém este valor não. Para auxiliar no tratamento de erro, criamos uma função
que formata uma saída e possui encapsulados uma execução de finalização.

[shell file="install.sh"]
function verifier_error() {
    echo ERROR: $1
    if [ ! -z $2 ]; then
        exit $2
    fi
}
if [ $USERID -ne 0 ]; then
    verifier_error "Necessário Usuário Raiz" 1
fi
[/shell]

Posteriormente, vamos inserir o módulo no kernel do Linux utilizando o comando
específico, esperando que sua execução tenha finalizado com sucesso. Caso
contrário, vamos gerar um erro dentro da instalação.

[shell file="install.sh"]
insmod "$DRIVER_NAME.ko"
if [ $? -ne 0 ]; then
    verifier_error "Impossível Instalar Módulo" 2
fi
[/shell]

Como o nosso módulo possui uma criação dinâmica de número maior, devemos
capturar este valor do conteúdo armazenado no arquivo com dispositivos do
sistema. Se ele não existir ou não estiver sido encontrado, também vamos gerar
um erro e finalizar a execução com uma saída diferente de zero.

[shell file="install.sh"]
MAJOR=$(grep "$DRIVER_NAME" /proc/devices | cut -d' ' -f1)
if [ -z $MAJOR ]; then
    verifier_error "Impossível Encontrar Número Maior" 3
fi
[/shell]

Finalizando, vamos remover qualquer tipo de dispositivo com o mesmo nome,
previamente criado e adicionar o nosso dispositivo de caractere com o mesmo
número maior do módulo adicionado anteriormente. No nosso caso, o número menor
não é significativo, portanto vamos configurá-lo com valor zero. Finalizamos o
instalador com uma saída igual a zero, demonstrando sucesso de execução.

[shell file="install.sh"]
rm -f "/dev/$DEVICE_NAME"
mknod "/dev/$DEVICE_NAME" c "$MAJOR" 0
chmod 666 "/dev/$DEVICE_NAME"
exit 0
[/shell]

Verificadora
------------

Vamos inicializar o desenvolvimento da verificadora de CPF/CNPJ, base da
Proposta de Trabalho de Grau B para a disciplina de Laboratório de Sistemas
Operacionais. Precisamos inicialmente criar um módulo que consiga gerar um
"número maior" automaticamente, com base no código fonte apresentado por CORBET
[2005].

Logo nas primeiras linhas, vamos configurar as informações do módulo, acessíveis
dentro do sistema operacional utilizando a função *modinfo*. Informamos uma
pequena descrição do módulo e seus autores, bem como o número da versão atual e
a licença de utilização do mesmo. Abaixo, apenas definimos algumas constantes
para utilização dentro da programação do módulo, que serão resolvidas logo no
início pelo pré-compilador.

[code file="verifier.c"]
MODULE_DESCRIPTION("Driver para Verificadora de CPF e CNPJ");
MODULE_AUTHOR("Wanderson Henrique Camargo Rosa <wandersonwhcr@gmail.com>");
MODULE_AUTHOR("Jeferson Souza <jeferson.s.souza@hotmail.com>");
MODULE_AUTHOR("Bruno Fagundes <web@bfagundes.com>");
MODULE_VERSION("0.1b");
MODULE_LICENSE("Dual BSD/CPL");

#define DRIVER_NAME "verifier"
#define MINOR_NUMBER 0
#define DEVICE_COUNTER 1
[/code]

Vamos adicionar as assinaturas das duas primeiras funções que serão
desenvolvidas durante o processo. Logo abaixo, elas são registradas como
inicialização e finalização de módulo. Conforme necessário, estas funções
possuem assinaturas compatíveis com os registradores de funções.

[code file="verifier.c"]
int verifier_init(void);
void verifier_exit(void);

module_init(verifier_init);
module_exit(verifier_exit);
[/code]

Para manipulação, vamos inicializar uma variável global e interna ao módulo para
armazenar o número referente ao dispositivo alocado. Este dispositivo
corresponde ao criado e anexado com o número maior dentro do instalador. No
nosso caso, o dispositivo deverá se chamar "verifier" e será criado dentro do
diretório de dispositivos padrão. Ele deve ser alocado dentro da função de
inicialização do módulo. Adicionamos algumas mensagens que serão visualizadas
somente no arquivo descrito na seção inicial deste documento.

[code file="verifier.c"]
dev_t device;

int verifier_init(void) {
    int result;
    printk(KERN_INFO "Inicialização de Verificadora CPF/CNPJ");
    result = alloc_chrdev_region(&device, MINOR_NUMBER, DEVICE_COUNTER, DRIVER_NAME);
    if (result == 0) {
        printk(KERN_INFO "Inicialização com Sucesso");
    } else {
        printk(KERN_ALERT "Impossível Alocação de Dispositivo");
    }
    return result;
}
[/code]

Buscando alocar o módulo, utilizamos a função específica para alocar um
dispositivo sem a existência de um número maior sendo informado dentro do código
fonte. Para outros elementos, utilizamos nossas definições descritas. Devemos
também apresentar os resultados ao final de inicializar o módulo.

Já a função de finalização é desenvolvida de maneira mais simples, solicitando
uma retirada do registro de dispositivos alocados o nosso alocado na
inicialização. Para isto, somente precimos informar o próprio valor do
dispositivo e a quantidade de elementos que devem sofrer esta ação; definido
anteriormente, o número de dispositivos é 1 (um).

[code file="verifier.c"]
void verifier_exit(void) {
    printk(KERN_INFO "Finalização de Verificadora CPF/CNPJ");
    unregister_chrdev_region(device, DEVICE_COUNTER);
    printk(KERN_INFO "Finalização com Sucesso");
}
[/code]

Com isto, temos um módulo que aloca um dispositivo para manipulação, anexando-se
ao elemento através de um número maior. No nosso caso, o instalador captura o
número variado criado.

Temos então um pequeno módulo de kernel do Linux que aloca um determinado
dispositivo. Este módulo trabalha como um _driver_. Como vamos criar uma leitora
de dados, precisamos adicionar funções de abertura, leitura, escrita e
fechamento deste dispositivo de caracteres, gerando assim nosso módulo de
verificação de CPF e CNPJ.

Alocação no Sistema Operacional
===============================

Neste momento, vamos inicializar um dispositivo de caractere dentro do sistema
operacional, fornecendo as operações que devem ser executadas quando o
dispositivo é acessado.

Operações Sobre Arquivos
------------------------

Neste momento, precisamos implementar 4 tipos de operações básicas: abertura,
leitura, escrita e fechamento do dispositivo de caracteres. Portanto, precisamos
implementar 4 funções que executam esta tarefa e fornecer a uma estrutura com
esta responsabilidade dentro da programação. Na área de assinaturas de funções,
vamos fornecer os seguintes protótipos.

[code file="verifier.c"]
int verifier_open(struct inode*, struct file*);
ssize_t verifier_read(struct file*, char __user*, size_t, loff_t*);
ssize_t verifier_write(struct file*, const char __user*, size_t, loff_t*);
int verifier_release(struct inode*, struct file*);
[/code]

Cada uma destas inicializações possui as suas características. A função para
leitura recebe como primeiro parâmetro um ponteiro para estrutura do
representante do arquivo dentro do sistema operacional; o segundo parâmetro
identifica o mesmo arquivo, porém com informações de sua abertura. Logo, temos
que o *inode* apresenta informações sobre a estrutura física do arquivo e o
parâmetro *file* apresenta informações sobre os descritores inicializados para
este arquivo.

Para executar a leitura, a segunda função armazena todas as execuções para esta
finalidade. O primeiro parâmetro *file*, assim como durante a abertura,
representa o arquivo aberto dentro do sistema, com informações sobre os
descritores inicializados. Já o segundo parâmetro *__user* representa um
ponteiro do tipo caractere para região de memória em espaço de usuário. O
parâmetro *size_t* indica a quantidade de _bytes_ que devem ser fornecidos para
a leitura. O último parâmetro *loff_t* fornece a posição atual da leitura no
arquivo apresentado. Como retorno, temos a quantidade de caracteres processados
com sucesso.

Com base na estrutura de leitura, a escrita recebe as mesmas quantidades de
parâmetros com funcionalidades semelhantes, porém o terceiro parâmetro *__user*
define um ponteiro para a região de memória em espaço de usuário que armazena os
valores para processamento.

As funções de leitura e escrita possuem uma peculiaridade, o valor de retorno
que representa a quantidade de caracteres processados. Se a função retorna o
mesmo valor solicitado para o utilização, então toda a quantidade de elementos
apresentada foi processada. Já se o valor retornado é menor do que o solicitado,
então uma quantidade menor foi processada. Se o valor retornado é igual a zero,
o final do arquivo foi alcançado. Por último, se o valor retornado é negativo,
então houve um erro durante o processamento. Estes erros estão definidos em
*linux/errno.h".

A última função representa o fechamento do arquivo pelo sistema operacional.
Esta somente é utilizada se todos os descritores de todos os processos foram
finalizados com sucesso. Caso seja necessário algum processamento quando um
descritor somente é fechado, temos que utilizar a função *flush*, não definida
no escopo acima.

Definição de Operações
----------------------

Para que as operações sejam apresentadas ao dispositivo de caractere que será
alocado no sistema operacional, precisamos armazená-las em uma estrutura com
esta finalidade. Esta estrutura do tipo *file_operations* recebe ponteiros para
as funções definidas nos protótipos.

[code file="verifier.c"]
struct file_operations verifier_fops = {
    .read    = verifier_read,
    .write   = verifier_write,
    .open    = verifier_open,
    .release = verifier_release,
};
[/code]

Assim, temos uma estrutura de nome *verifier_fops* com os ponteiros devidamente
inicializados com as funções para manipulação de arquivos. Vale lembrar que
estas funções necessitam possuir os parâmetros necessários, característica de
sua tipagem. Este tipo de inicialização de estrutura corresponde ao formato C99.

Alocação do Dispositivo
-----------------------

Agora vamos alocar o dispositivo de caractere no sistema operacional, fornecendo
a estrutura de operações em arquivos definida anteriormente. Logo após a
confirmação de inicialização com sucesso do _driver_, vamos solicitar ao sistema
a alocação de um novo dispositivo de caractere.

[code file="verifier.c"]
// Definido como Global
struct cdev *cdevice;
// Estrutura de Inicialização
cdevice = cdev_alloc();
cdevice->ops = &verifier_fops;
result = cdev_add(cdevice, device, DEVICE_COUNTER);
[/code]

Com a devida alocação do dispositivo, apresentamos como operadores o endereço
para a estrutura com os operadores de arquivos definida anteriormente.  A
terceira linha tenta adicionar o dispositivo no sistema operacional, utilizando
como primeiro parâmetro o dispositivo alocado e segundo o dispositivo físico
inicializado com o _driver_. O último parâmetro representa a quantidade de
dispositivos que irão ser utilizados com esta alocação.

Vale lembrar que *cdevice* é uma variável global que está definida fora do
escopo das funções e pode ser acessada por qualquer uma delas, inclusive na
finalização do módulo, que precisa desalocar o recurso. Já a variável *device* e
a definição DEVICE_COUNTER foram criadas anteriormente, durante a inicialização
básica do módulo.

Novamente, vamos armazenar o resultado do processamento em *result* e criar um
tratamento de possível erro de alocação.

[code file="verifier.c"]
if (result == 0) {
    // Alocação com Sucesso
    printk(KERN_INFO "Alocação com Sucesso");
} else {
    // Alocação com Erros
    printk(KERN_ALERT "Impossível Alocar Dispositivo no Sistema");
}
[/code]

Agora precisamos desalocar a inicialização do dispositivo de caractere no
sistema operacional. Durante a finalização do módulo, antes de remover a região
disponibilizada para o dispositivo, vamos desalocar o dispositivo de caractere.

[code file="verifier.c"]
cdev_del(cdevice);
[/code]

Assim, temos o nosso dispositivo de caractere devidamente inicializado, bastando
escrever as funções com operações de arquivos que somente foram definidas como
protótipos.

Escrita de Operações
--------------------

As operações iniciais para arquivos devem ser definidas de forma bem simples,
somente para fornecer ao sistema operacional as devidas entradas. As próximas
seções do documento deverão discutir cada uma delas. Por hora, as funções de
abertura e fechamento retornam sucesso para qualquer solicitação; já as
responsáveis pela leitura e escrita somente apresentam a quantidade de _bytes_
processados e final de arquivo, respectivamente.

[code file="verifier.c"]
// Abertura
int verifier_open(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Abertura de Arquivo");
    return 0;
}
// Leitura
size_t verifier_read(struct file* filp, char __user* buffer, size_t count, loff_t* offp) {
    printk(KERN_DEBUG "Leitura em Arquivo");
    return count;
}
// Escrita
ssize_t verifier_write(struct file* filp, const char __user* buffer, size_t count, loff_t* offp) {
    printk(KERN_DEBUG "Escrita em Arquivo");
    return count;
}
// Fechamento
int verifier_release(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Fechamento de Arquivo");
    return 0;
}
[/code]

As exibições do tipo *KERN_DEBUG* não são armazenadas no arquivo de mensagens,
mas somente no arquivo */var/log/kern.log*. Como todas as mensagens podem ser
acessdas neste local, podemos utilizar o comando *tail -f* neste arquivo para
visualizar as saídas em *printk* apresentadas no programa.

Como temos todas as inicializações para operações com arquivos devidamente
inicializadas, podemos começar o desenvolvimento da implementação da
verificadora de documentos do tipo CPF e CNPJ, proposta do Trabalho de Grau B
desta disciplina.

Abertura e Liberação de Arquivo
-------------------------------

Durante a abertura e fechamento de arquivos, precisamos desenvolver duas funções
para que saibamos quando estas duas execuções estão sendo chamadas. Porém, como
não estaremos utilizando realmente arquivos, podemos somente confirmar ao
sistema operacional a abertura e fechamento dos recursos, retornando o valor de
sucesso.

Somente para auxiliar o desenvolvimento, exibimos mensagens sempre que estas
funções são executadas, exibindo o tempo de abertura e fechamento do arquivo.

[code file="verifier.c"]
int verifier_open(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Abertura de Arquivo");
    return 0;
}
int verifier_release(struct inode* inode, struct file* filp) {
    printk(KERN_DEBUG "Fechamento de Arquivo");
    return 0;
}
[/code]

A abertura é feita sempre que um processo solicita a abertura do arquivo pela
primeira vez. Porém, se outro processo já executou esta solicitação, teremos a
função não será executada novamente, tendo em vista que o *inode* já foi aberto
pelo sistema operacional. Da mesma forma, a liberação do recurso pela função de
fechamento do arquivo somente é executada quando todos os descritores daquele
arquivo foram finalizados. Se precisamos chamar algum recurso quando um único
descritor é finalizado, devemos utilizar a função *flush*, não utilizada neste
trabalho.

Escrita de Arquivo
------------------

A função para escrita em arquivo sempre é chamada quando algum processo executa
a chamada de sistema para escrita em descritor representante. Portando, sempre
que existe uma escrita, a função de abertura de arquivo já foi executada
anteriormente. Primeiramente, vamos desenvolver uma estruturação simples que
busca apresentar um erro de entrada e saída sempre que um processo tenta
executar uma escrita na leitora.

[code file="verifier.c"]
ssize_t verifier_write(struct file* filp, const char __user* buffer, size_t count, loff_t* offp) {
    int result = -EIO; // Problema de Entrada e Saída
    printk(KERN_DEBUG "Escrita em Arquivo");
    if (count == 12 || count == 15) { // (CPF|CNPJ) + 1
        // Tamanho Válido do Documento
    } else {
        // Tamanho do Documento Inválido
        printk(KERN_ALERT "Documento não Reconhecido");
    }
    return result;
}
[/code]

Neste bloco de código também colocamos a verificação da quantidade de caracteres
que foi informada para escrita. Sem os caracteres de máscara, um documento do
tipo CPF possui 11 caracteres e um CNPJ possui 14 caracteres. Porém, devemos
considerar o caractere identificador de final de string, portando sempre
verificamos se existe a quantidade solicitada adicionada de uma unidade.

Agora podemos iniciar a captura dos caracteres apresentados. Vamos então salvar
em memória no espaço de Kernel a informação passada durante a chamada da função.
Para isto, precisamos alocar um espaço de memória com a mesma quantidade de
bytes que foi apresentada durante a escrita. Vamos então criar uma variável
global do tipo ponteiro de caractere. Para facilitar a contabilização do tamanho
de memória alocada, também vamos criar uma variável global para armazenar esta
informação.

[code file="verifier.c"]
char *memory;
int memorysize;
[/code]

Agora vamos liberar o espaço de memória, porque ele pode ter sido alocado em
situações anteriores de escrita. Logo após, alocamos um espaço de memória do
mesmo tamanho da quantidade de caracteres apresentada, utilizando uma alocação
normal de Kernel.

[code file="verifier.c"]
kfree(memory);
memory = kmalloc(count, GFP_KERNEL);
[/code]

Caso esta alocação não tenha sido executada com sucesso, o valor da posição em
memória retornada será nula. Caso isto aconteça, vamos informar sobre o
problema.

[code file="verifier.c"]
if (memory != NULL) {
    // Alocação com Sucesso
} else {
    printk(KERN_ALERT "Problema na Alocação de Memória");
}
[/code]

Com sucesso durante a alocação de memória, somente vamos limpar o espaço de
memória fornecido conforme a quantidade de espaço alocada. Portanto, vamos
preencher o espaço de memória com valores iniciais.

[code file="verifier.c"]
memset(memory, 0, count);
[/code]

Agora precisamos copiar os caracteres que foram apresentados durante a chamada
de sistema para escrita em arquivo. Estes caracteres estão armazenados em espaço
de usuário e devem ser copiados para espaço de Kernel para manipulação.
Precisamos contabilizar a quantidade de caracteres necessários e armazenar este
valor na variável global para tamanho de memória.

Utilizando uma função específica para cópia de conteúdo do espaço de usuário
para espaço de Kernel, precisamos apresentar a posição de memória destino da
cópia, ou seja, a memória alocada inicialmente. Também vamos apresentar o local
onde o conteúdo origem está armazenado em espaço de usuário e a quantidade de
caracteres que será copiada.

Esta chamada para cópia retorna a quantidade de bytes que não foram processados.
Caso a função apresente valor igual a zero, temos todos os bytes copiados com
sucesso; caso contrário teremos um erro ao copiar os caracteres do documento. Em
sucesso, vamos apresentar a quantidade de caracteres processados no resultado da
função, não mais informando problema de entrada e saída.

[code file="verifier.c"]
memorysize = count - 1; // Tamanho da Memória
if (copy_from_user(memory, buffer, memorysize) == 0) {
    printk(KERN_INFO "Conteúdo Escrito: %s", memory);
    result = count; // Sucesso no Processamento
} else {
    printk(KERN_ALERT "Erro ao Copiar Conteúdo do Documento");
}
[/code]

O código para escrita em arquivo para a verificadora foi finalizado com sucesso.
Esta função exige que a quantidade de caracteres escrita esteja do mesmo tamanho
que um documento do tipo CPF ou CNPJ sem máscara. Qualquer erro encontrado
apresenta um problema de entrada e saída. Abaixo temos o código completo com
todos os passos para processamento de escrita ao dispositivo de caractere.

[code file="verifier.c"]
// Variáveis Globais
char *memory;
int memorysize;

// Função de Escrita
ssize_t verifier_write(struct file* filp, const char __user* buffer, size_t count, loff_t* offp) {
    int result = -EIO; // Problema de Entrada e Saída
    printk(KERN_DEBUG "Escrita em Arquivo");
    if (count == 12 || count == 15) { // (CPF|CNPJ) + 1
        kfree(memory);
        memory = kmalloc(count, GFP_KERNEL);
        if (memory != NULL) {
            memset(memory, 0, count);
            memorysize = count - 1; // Tamanho da Memória
            if (copy_from_user(memory, buffer, memorysize) == 0) {
                printk(KERN_INFO "Conteúdo Escrito: %s", memory);
                result = count; // Sucesso no Processamento
            } else {
                printk(KERN_ALERT "Erro ao Copiar Conteúdo do Documento");
            }
        } else {
            printk(KERN_ALERT "Problema na Alocação de Memória");
        }
    } else {
        // Tamanho do Documento Inválido
        printk(KERN_ALERT "Documento não Reconhecido");
    }
    return result;
}
[/code]

Leitura em Arquivo
------------------

A leitura do arquivo necessita de que o número de documento CPF e CNPJ seja
anteriormente apresentado com uma escrita em arquivo. Logo, precisamos armazenar
na leitora o número do documento antes de efetuar a chamada de sistema para
leitura do arquivo, caso contrário teremos um problema de entrada e saída,
apresentado caso este erro seja encontrado.

[code file="verifier.c"]
ssize_t verifier_read(struct file* filp, char __user* buffer, size_t count, loff_t* offp) {
    int result = -EIO; // Erro de Entrada e Saída
    printk(KERN_DEBUG "Leitura em Arquivo");
    return result;
}
[/code]

Precisamos saber se a posição de memória que contém informações sobre o número
de documento para verificação foi inicializada corretamente ou se ela já foi
utilizada em algum momento do processamento. Se a posição já foi utilizada,
vamos armazenar o valor nulo posteriormente. Agora, precisamos saber qual é o
conteúdo deste ponteiro de memória e se ele já foi processado.

[code file="verifier.c"]
// Verificar Alocação de Memória
if (memory != NULL) {
    // Inicializada e Não Utilizada
} else {
    // Não Inicializada ou Utilizada Anteriormente
}
[/code]

Se a posição de memória foi inicializada e não utilizada, devemos utilizar o seu
conteúdo e verificar o valor armazenado, fazendo uma confirmação de documento
CPF ou CNPJ com valor correto. Isto será desenvolvido posteriormente, porém
vamos efetuar a chamada da função responsável e adicionar o seu protótipo no
topo do documento. O seu retorno será armazenado em uma variável global que
apresenta a última verificação. O código abaixo apresenta o conteúdo a ser
armazenado como global.

[code file="verifier.c"]
// Protótipo
char verifier_document(char*,int);
// Variável Global para Última Verificação
char lastcheck;
[/code]

A execução da verificação será encapsulada na função, porém como temos o
protótipo adicionado, poderemos utilizar a função normalmente neste local. A
função de verificação recebe como primeiro parâmetro a posição de memória para
verificação e como segundo a quantidade de caracteres que devem ser verificados,
identificando assim um documento do tipo CPF ou CNPJ.

[code file="verifier.c"]
// Processar Resultado
lastcheck = verifier_document(memory, memorysize);
printk(KERN_INFO "Resultado de Verificação: %c", lastcheck);
[/code]

Este retorno será apresentado à chamada de sistema como único caractere
resultado da leitura, identificando assim o resultado da verificação do
documento. Este caractere deve ser copiado para o espaço de usuário como
resultado da leitura. Em caso de sucesso, teremos que desalocar a memória
inicializada anteriormente durante a escrita, limpar o ponteiro deste local e
reduzir o tamanho da memória a zero, identificando assim o final da verificação
do documento. O retorno será marcado como 1, confirmando a leitura do único
caractere apresentado ao espaço de usuário.

A função de cópia para espaço de usuário retorna a quantidade de caracteres que
não foram processados. Caso o único caractere não tenha sido copiado, vamos
apresentar uma mensagem de alerta.

[code file="verifier.c"]
if (copy_to_user(buffer, &lastcheck, 1) == 0) {
    printk(KERN_INFO "Conteúdo Lido: %c", lastcheck);
    // Limpar Memória
    kfree(memory);
    memory = NULL;
    memorysize = 0;
    // Quantidade de Leitura
    result = 1; // Somente 1 Caractere
} else {
    printk(KERN_ALERT "Erro ao Copiar o Conteúdo de Resposta");
}
[/code]

Por outro lado, se a posição de memória está com valor nulo, ou seu
processamento não foi inicializado corretamente ou sua verificação já foi
executada. Devemos consultar a variável que armazena a última verificação. Em
caso de sucesso ou falha, o conteúdo foi processado. Caso contrário, vamos
apresentar uma mensagem de alerta informando que a posição não foi inicializada
corretamente.

[code file="verifier.c"]
// Verificar Última Leitura
if (lastcheck == VERIFIER_SUCCESS || lastcheck == VERIFIER_FAIL) {
    // Quantidade de Leitura
    lastcheck = VERIFIER_WAIT; // Estado em Espera
    result = 0; // Sinalização de Final do Arquivo
    printk(KERN_ALERT "Final do Arquivo Encontrado");
} else {
    printk(KERN_ALERT "Conteúdo não Inicializado Anteriormente");
}
[/code]

Ainda em caso de sucesso ou falha na verificação do conteúdo, temos o resultado
que será apresentado no retorno da função de leitura marcado como nenhum
caractere lido. Isto sinaliza o final do arquivo. Precisamos executar esta
marcação porque muitos programas executam a leitura sobre o conteúdo de todo o
arquivo; caso este valor não seja apresentado, teremos gerado uma leitura que
nunca será finalizada.

Este código também apresenta algumas constantes, utilizadas como retorno da
verificadora do conteúdo do documento. Estas constantes estão definidas fora do
escopo da função de leitura e são utilizadas internamente como marcadores de
documento com conteúdo processado com sucesso, falha no processamento ou que a
leitora está em estado de espera de conteúdo para escrita.

[code file="verifier.c"]
// Definições
#define VERIFIER_SUCCESS '0'
#define VERIFIER_FAIL '1'
#define VERIFIER_WAIT '2'
[/code]

Estes valores também são os conteúdo apresentados para a leitura da
verificadora, sinalizando sucesso ou falha na verificação do conteúdo do
documento solicitado.

O bloco de código para leitura do arquivo é apresentado de forma completa. Temos
a verificação do conteúdo somente se uma escrita na verificadora foi executada
anteriormente, caso contrário apresentamos um erro de entrada e saída. Este
conteúdo é apresentado para a função de verificação, que apresenta um resultado
de sucesso ou falha no resultado da checagem. Este conteúdo também é enviado
para o espaço de usuário informando, trabalhando como caracteres resultados da
leitura. Na próxima requisição de leitura, apresentamos um resultado zerado,
sinalizando o final do arquivo.

[code file="verifier.c"]
ssize_t verifier_read(struct file* filp, char __user* buffer, size_t count, loff_t* offp) {
    int result = -EIO; // Erro de Entrada e Saída
    printk(KERN_DEBUG "Leitura em Arquivo");
    // Verificar Alocação de Memória
    if (memory != NULL) {
        lastcheck = verifier_document(memory, memorysize);
        printk(KERN_INFO "Resultado de Verificação: %c", lastcheck);
        if (copy_to_user(buffer, &lastcheck, 1) == 0) {
            printk(KERN_INFO "Conteúdo Lido: %c", lastcheck);
            // Limpar Memória
            kfree(memory);
            memory = NULL;
            memorysize = 0;
            // Quantidade de Leitura
            result = 1; // Somente 1 Caractere
        } else {
            printk(KERN_ALERT "Erro ao Copiar o Conteúdo de Resposta");
        }
    } else {
        // Verificar Última Leitura
        if (lastcheck == VERIFIER_SUCCESS || lastcheck == VERIFIER_FAIL) {
            // Quantidade de Leitura
            lastcheck = VERIFIER_WAIT; // Estado em Espera
            result = 0; // Sinalização de Final do Arquivo
            printk(KERN_ALERT "Final do Arquivo Encontrado");
        } else {
            printk(KERN_ALERT "Conteúdo não Inicializado Anteriormente");
        }
    }
    return result;
}
[/code]

Agora podemos apresentar a função que efetua a verificação de um CPF ou CNPJ
conforme a quantidade de caracteres apresentados.

Algoritmo de Verificação
------------------------

O Cadastro de Pessoa Física (CPF) e o Cadastro Nacional de Pessoa Jurídica
(CNPJ) são documentos que identificam pessoas junto à Receita Federal
brasileira. Estes documentos são formados por dígitos que podem ser validados
através da execução de um algoritmo posicional com pesos.

Para fins computacionais, podemos criar uma função que receba como entrada uma
sequência de caracteres e retorne uma confirmação se o valor é considerado um
documento do tipo CPF ou CNPJ válido. Estar válido não quer dizer existente,
somente que o documento informado passou sobre os testes de validação.

A função anteriormente definida deve ser acrescentada aos protótipos do
programa. Adicionando ao final do documento, vamos criar uma função que crie
esta validação sobre os dados apresentados. Como não temos como contar o tamanho
da entrada, vamos também apresentar esta informação como parâmetro, facilitando
inclusive na verificação do tipo de documento.

[code file="verifier.c"]
// Protótipos
char verifier_document(char*,int);

// Função Inicializada
char verifier_document(char* content, int size) {
    return VERIFIER_SUCCESS;
}
[/code]

Podemos conferir a utilização de definições anteriormente apresentadas,
fornecendo o caso de sucesso no início deste desenvolvimento. Outras definições
vão ser utilizadas no decorrer do desenvolvimento desta função. Um CNPJ possui
tamanho fixo de 14 caracteres numéricos retirando a máscara de formatação. Já o
CPF possui apenas 11 caracteres.

Primeiramente vamos inicializar as variáveis utilizadas no escopo da função.
Podemos conferir que existe uma variável que armazena os modificadores de
execução. Estes valores são os pesos que devem ser aplicados às posições do
número do documento. 

[code file="verifier.c"]
// Variáveis
int index; // Chave para Iterações
int comparison; // Comparações Variadas
// Modificadores
int* modifiers;
int modifiers_cpf[]  = {11,10,9,8,7,6,5,4,3,2};
int modifiers_cnpj[] = {6,5,4,3,2,9,8,7,6,5,4,3,2};
[/code]

Logo no início da programação, verificamos se o conteúdo apresentado possui
tamanho fixo de 11 ou 14 caracteres, atribuindo os modificadores à variável
correta para processamento. Caso estes dois primeiros requisitos não são
válidos, vamos retornar uma falha de verificação.

[code file="verifier.c"]
// Verificar Tamanho CPF ou CNPJ
if (size == 11) {
    // Modificadores para CPF
    modifiers = modifiers_cpf;
} else if (size == 14) {
    // Modificadores para CNPJ
    modifiers = modifiers_cnpj;
} else {
    // Tamanho Inválido
    printk(KERN_ALERT "Tamanho do Documento Inválido");
    return VERIFIER_FAIL;
}
[/code]

Logo após vamos executar um laço de repetição para o conteúdo apresentado,
verificando se existem somente caracteres númericos. Logo após, executamos uma
tarefa considerada como expansão de caracteres, checando se todos os caracteres
são idênticos. O algoritmo fornece como correto todo documento que possui todos
os dígitos iguais, portanto precisamos executar esta tarefa separadamente.

[code file="verifier.c"]
// Verificar Conteúdo com Números Somente
for (index = 0; index < size; index = index + 1) {
    // Buscar no Intervalo [0-9]
    if (content[index] < '0' || content[index] > '9') {
        printk(KERN_ALERT "Documento Necessita Somente Números");
        return VERIFIER_FAIL;
    }
}

// Verificar Dígitos Expandidos
comparison = 1; // Confirmação Inicial
for (index = 0; index < size; index = index + 1) {
    comparison = comparison && (content[0] == content[index]);
}
if (comparison) {
    // Todos Dígitos Idênticos
    printk(KERN_ALERT "Documento com Dígitos Idênticos");
    return VERIFIER_FAIL;
}
[/code]

Agora podemos executar o algoritmo de verificação de posicionamento com pesos.
A execução da tarefa é idêntica para ambos os números de documento, porém a
quantidade de pesos e seus valores são diferentes.

Cada posição recebe um peso até o antepenúltimo número, sendo que efetuamos o
somatório da multiplicação dos pesos com a posição. Se o resto da divisão por 11
neste somatório for inferior a 2, devemos apresentar 0 como resultado; caso
contrário, devemos apresentar o complemento deste resto sobre 11. Para
comparação, vamos adicionar 48 unidades ao conteúdo da posição para fins de
verificação, manipulando o resultado como uma conversão alfanumérica para
inteiro, utilizando a tabela ASCII. O caractere encontrado deve ser idêntico ao
penúltimo caractere, finalizando a verificação de primeiro nível.

A verificação de segundo nível é executada da mesma maneira, porém até a
penúltima posição do conteúdo. O resultado encontrado deve ser conferido com o
último caractere.

[code file="verifier.c"]
// Verificação com Modificadores Nível 1
comparison = 0;
for (index = 1; index < size - 1; index = index + 1) {
    comparison = comparison + modifiers[index] * (content[index - 1] - 48); // Conversão ATOI
}
printk(KERN_DEBUG "Comparação Nível 1 Somatório: %d", comparison);
comparison = comparison % 11;
comparison = (comparison < 2 ? 0 : 11 - comparison) + 48; // Conversão ITOA
if (comparison != content[size - 2]) {
    printk(KERN_ALERT "Verificação de Primeiro Nível Inválida");
    return VERIFIER_FAIL;
}

// Verificação com Modificadores Nível 2
comparison = 0;
for (index = 0; index < size - 1; index = index + 1) {
    comparison = comparison + modifiers[index] * (content[index] - 48); // Conversão ATOI
}
printk(KERN_DEBUG "Comparação Nível 2 Somatório: %d", comparison);
comparison = comparison % 11;
comparison = (comparison < 2 ? 0 : 11 - comparison) + 48; // Conversão ITOA
if (comparison != content[size - 1]) {
    printk(KERN_ALERT "Verificação de Segundo Nível Inválida");
    return VERIFIER_FAIL;
}
[/code]

Se tudo ocorrer corretamente, podemos considerar o conteúdo do documento como um
CPF ou CNPJ válido, apresentando a definição de sucesso como retorno da função.

[code file="verifier.c"]
printk(KERN_INFO "Verificação do Documento com Sucesso");
return VERIFIER_SUCCESS;
[/code]

Após o término do desenvolvimento desta função, podemos instalar o módulo no
Sistema Operacional utilizando o _script_ de instalação anteriormente
desenvolvido. Este executável irá adicionar um dispositivo de caractere e irá
instalar o módulo como um _driver_ para o mesmo. Agora podemos criar um caso de
teste para utilização.

Testando o Módulo
-----------------

Como anteriormente descrito, o módulo para verificação de documentos do tipo CPF
e CNPJ trabalha com dois passos distintos, escrita de determinado conteúdo no
dispositivo de caractere que identifica o documento. Após, durante a leitura,
receberemos como resposta um caractere 0 se o resultado esperado estiver
correto, caso contrário será retornado o caractere 1.

[code]
echo 72875866818 > /dev/verifier # Escrita com Sucesso
cat /dev/verifier # Resultado Esperado: 0
[/code]

Isto tambem pode ser executado com dígitos que simbolizam documentos do tipo
CNPJ da mesma forma. O tipo de documento é verificado pela quantidade de
caracteres apresentados para verificação.

[code]
echo 29656444000161 > /dev/verifier # Escrita com Suceso
cat /dev/verifier # Resultado Esperado: 0
[/code]

Podemos forçar o erro ao informar um número de documento inválido para o
algoritmo, como quantidade de caracteres diferente, números expandidos,
caracteres inválidos ou documento não reconhecido.

[code]
echo 12345 > /dev/verifier # Quantidade de Caracteres
cat /dev/verifier # Resultado Esperado: 1
echo 11111111111 > /dev/verifier # Expansão Numérica
cat /dev/verifier # Resultado Esperado: 1
echo abcd > /dev/verifier # Caracteres Inválidos
cat /dev/verifier # Resultado Esperado: 1
echo 72875866817 > /dev/verifier # Não Reconhecido
cat /dev/verifier # Resultado Esperado: 1
[/code]

Caso alguma verificação seja solicitada se não existe um conteúdo para
manipulação no dispositivo de caractere, um erro de entrada e saída é
apresentado durante a leitura.

[code]
cat /dev/verifier # Erro de Entrada e Saída
cat: /dev/verifier: Input/output error
[/code]

Problemas Encontrados
---------------------

O _driver_ para o dispositivo de caractere não trabalha de alguma forma com
prevenção de solicitações paralelas. Dois processos podem concorrentemente
acessar o dispositivo e causar um problema de entrada e saída, onde o primeiro
irá fornecer um conteúdo e o segundo logo após. Quando o primeiro solicitar a
verificação, a resposta será do segundo processo. Já quando o segundo processo
efetuar a leitura, teremos um problema de entrada e saída.

Isto pode ser executado com algum tipo de verificação atômica ou com
fornecimento de algum tipo de verificador que pode ser apresentado durante a
leitura, como tabela _hash_ para o identificador do processo que está
solicitando a verificação.

Outro problema é que dois dispositivos não podem acessar ao mesmo tempo a
verificadora, causando problemas desconhecidos. Se um processo executou a tarefa
de abertura de descritor para o dispositivo, outro processo não pode ter esta
tarefa. Isto poderia ser resolvido marcando o dispositivo como arquivo
previamente aberto, apresentando algum aviso quando houver tentativa de leitura
ou escrita.

Conclusões
----------

O desenvolvimento de um módulo para o Kernel do Linux parece ser complicado logo
no início, principalmente por não fornecer as bibliotecas padrão da linguagem C.
Muitas execuções necessitam ser processadas de uma forma mais baixo nível do que
já conhecemos.

Também temos que ter o cuidado de retirar todas as alocações de recursos de
forma correta, como posições de memória inicializadas e reservadas para o
Kernel.

A criação de um dispositivo virtual capaz de verificar se um documento do tipo
CPF ou CNPJ é válido pode trazer início ao desenvolvimento de um _driver_ real
para leitoras destes tipos de documento. Também poderão ser criados _drivers_
para dispositivos verificadores de boleto ou catracas eletrônicas, por exemplo.
